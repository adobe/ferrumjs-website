<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Home - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-hashing-DefaultHasher.html">DefaultHasher</a><ul class='methods'><li data-type='method'><a href="module-hashing-DefaultHasher.html#.fromSeed">fromSeed</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#.new">new</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#.withOpts">withOpts</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#buildHasher">buildHasher</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#digest">digest</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#update">update</a></li></ul></li><li><a href="module-hashing-HashMap.html">HashMap</a><ul class='methods'><li data-type='method'><a href="module-hashing-HashMap.html#.fromSeq">fromSeq</a></li><li data-type='method'><a href="module-hashing-HashMap.html#.fromSeqWithOpts">fromSeqWithOpts</a></li><li data-type='method'><a href="module-hashing-HashMap.html#.new">new</a></li><li data-type='method'><a href="module-hashing-HashMap.html#clear">clear</a></li><li data-type='method'><a href="module-hashing-HashMap.html#delete">delete</a></li><li data-type='method'><a href="module-hashing-HashMap.html#entries">entries</a></li><li data-type='method'><a href="module-hashing-HashMap.html#forEach">forEach</a></li><li data-type='method'><a href="module-hashing-HashMap.html#get">get</a></li><li data-type='method'><a href="module-hashing-HashMap.html#getPair">getPair</a></li><li data-type='method'><a href="module-hashing-HashMap.html#has">has</a></li><li data-type='method'><a href="module-hashing-HashMap.html#keys">keys</a></li><li data-type='method'><a href="module-hashing-HashMap.html#set">set</a></li><li data-type='method'><a href="module-hashing-HashMap.html#size">size</a></li><li data-type='method'><a href="module-hashing-HashMap.html#values">values</a></li></ul></li><li><a href="module-hashing-HashSet.html">HashSet</a><ul class='methods'><li data-type='method'><a href="module-hashing-HashSet.html#.fromSeq">fromSeq</a></li><li data-type='method'><a href="module-hashing-HashSet.html#.fromSeqWithOpts">fromSeqWithOpts</a></li><li data-type='method'><a href="module-hashing-HashSet.html#.new">new</a></li><li data-type='method'><a href="module-hashing-HashSet.html#add">add</a></li><li data-type='method'><a href="module-hashing-HashSet.html#clear">clear</a></li><li data-type='method'><a href="module-hashing-HashSet.html#delete">delete</a></li><li data-type='method'><a href="module-hashing-HashSet.html#entries">entries</a></li><li data-type='method'><a href="module-hashing-HashSet.html#forEach">forEach</a></li><li data-type='method'><a href="module-hashing-HashSet.html#get">get</a></li><li data-type='method'><a href="module-hashing-HashSet.html#has">has</a></li><li data-type='method'><a href="module-hashing-HashSet.html#size">size</a></li><li data-type='method'><a href="module-hashing-HashSet.html#values">values</a></li></ul></li><li><a href="module-hashing-UnorderedHasher.html">UnorderedHasher</a><ul class='methods'><li data-type='method'><a href="module-hashing-UnorderedHasher.html#.fromBuildHasher">fromBuildHasher</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#.new">new</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#.withOpts">withOpts</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#buildHasher">buildHasher</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#digest">digest</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#update">update</a></li></ul></li><li><a href="module-trait-HybridWeakMap.html">HybridWeakMap</a></li><li><a href="module-trait-Trait.html">Trait</a><ul class='methods'><li data-type='method'><a href="module-trait-Trait.html#impl">impl</a></li><li data-type='method'><a href="module-trait-Trait.html#implDerived">implDerived</a></li><li data-type='method'><a href="module-trait-Trait.html#implStatic">implStatic</a></li><li data-type='method'><a href="module-trait-Trait.html#implWild">implWild</a></li><li data-type='method'><a href="module-trait-Trait.html#implWildStatic">implWildStatic</a></li><li data-type='method'><a href="module-trait-Trait.html#invoke">invoke</a></li><li data-type='method'><a href="module-trait-Trait.html#lookupType">lookupType</a></li><li data-type='method'><a href="module-trait-Trait.html#lookupValue">lookupValue</a></li></ul></li><li><a href="module-trait-TraitNotImplemented.html">TraitNotImplemented</a></li></ul><h3>Modules</h3><ul><li><a href="module-functional.html">functional</a><ul class='methods'><li data-type='method'><a href="module-functional.html#~apply">apply</a></li><li data-type='method'><a href="module-functional.html#~apply1">apply1</a></li><li data-type='method'><a href="module-functional.html#~call">call</a></li><li data-type='method'><a href="module-functional.html#~compose">compose</a></li><li data-type='method'><a href="module-functional.html#~curry">curry</a></li><li data-type='method'><a href="module-functional.html#~exec">exec</a></li><li data-type='method'><a href="module-functional.html#~identity">identity</a></li><li data-type='method'><a href="module-functional.html#~let_in">let_in</a></li><li data-type='method'><a href="module-functional.html#~pipe">pipe</a></li><li data-type='method'><a href="module-functional.html#~withFunctionName">withFunctionName</a></li></ul></li><li><a href="module-hashing.html">hashing</a><ul class='methods'><li data-type='method'><a href="module-hashing.html#~bytes2hex">bytes2hex</a></li><li data-type='method'><a href="module-hashing.html#~defaultBuildHasher">defaultBuildHasher</a></li><li data-type='method'><a href="module-hashing.html#~hash">hash</a></li><li data-type='method'><a href="module-hashing.html#~hashDirectly">hashDirectly</a></li><li data-type='method'><a href="module-hashing.html#~hashmap">hashmap</a></li><li data-type='method'><a href="module-hashing.html#~hashSeq">hashSeq</a></li><li data-type='method'><a href="module-hashing.html#~hashSeqWith">hashSeqWith</a></li><li data-type='method'><a href="module-hashing.html#~hashset">hashset</a></li><li data-type='method'><a href="module-hashing.html#~hashUnordered">hashUnordered</a></li><li data-type='method'><a href="module-hashing.html#~hashUnorderedWith">hashUnorderedWith</a></li><li data-type='method'><a href="module-hashing.html#~hashWith">hashWith</a></li><li data-type='method'><a href="module-hashing.html#~hex2bytes">hex2bytes</a></li><li data-type='method'><a href="module-hashing.html#~randomBuildHasher">randomBuildHasher</a></li><li data-type='method'><a href="module-hashing.html#~seededBuildHasher">seededBuildHasher</a></li><li data-type='method'><a href="module-hashing.html#~unorderedBuildHasher">unorderedBuildHasher</a></li></ul></li><li><a href="module-op.html">op</a><ul class='methods'><li data-type='method'><a href="module-op.html#~aint">aint</a></li><li data-type='method'><a href="module-op.html#~and">and</a></li><li data-type='method'><a href="module-op.html#~is">is</a></li><li data-type='method'><a href="module-op.html#~mul">mul</a></li><li data-type='method'><a href="module-op.html#~nand">nand</a></li><li data-type='method'><a href="module-op.html#~nor">nor</a></li><li data-type='method'><a href="module-op.html#~not">not</a></li><li data-type='method'><a href="module-op.html#~or">or</a></li><li data-type='method'><a href="module-op.html#~plus">plus</a></li><li data-type='method'><a href="module-op.html#~xnor">xnor</a></li><li data-type='method'><a href="module-op.html#~xor">xor</a></li></ul></li><li><a href="module-sequence.html">sequence</a><ul class='methods'><li data-type='method'><a href="module-sequence.html#~all">all</a></li><li data-type='method'><a href="module-sequence.html#~any">any</a></li><li data-type='method'><a href="module-sequence.html#~append">append</a></li><li data-type='method'><a href="module-sequence.html#~assertSequenceEquals">assertSequenceEquals</a></li><li data-type='method'><a href="module-sequence.html#~cartesian">cartesian</a></li><li data-type='method'><a href="module-sequence.html#~cartesian2">cartesian2</a></li><li data-type='method'><a href="module-sequence.html#~chunkify">chunkify</a></li><li data-type='method'><a href="module-sequence.html#~chunkifyShort">chunkifyShort</a></li><li data-type='method'><a href="module-sequence.html#~chunkifyWithFallback">chunkifyWithFallback</a></li><li data-type='method'><a href="module-sequence.html#~concat">concat</a></li><li data-type='method'><a href="module-sequence.html#~contains">contains</a></li><li data-type='method'><a href="module-sequence.html#~count">count</a></li><li data-type='method'><a href="module-sequence.html#~dict">dict</a></li><li data-type='method'><a href="module-sequence.html#~each">each</a></li><li data-type='method'><a href="module-sequence.html#~enumerate">enumerate</a></li><li data-type='method'><a href="module-sequence.html#~extend">extend</a></li><li data-type='method'><a href="module-sequence.html#~extend1">extend1</a></li><li data-type='method'><a href="module-sequence.html#~filter">filter</a></li><li data-type='method'><a href="module-sequence.html#~find">find</a></li><li data-type='method'><a href="module-sequence.html#~first">first</a></li><li data-type='method'><a href="module-sequence.html#~flat">flat</a></li><li data-type='method'><a href="module-sequence.html#~flattenTree">flattenTree</a></li><li data-type='method'><a href="module-sequence.html#~foldl">foldl</a></li><li data-type='method'><a href="module-sequence.html#~foldr">foldr</a></li><li data-type='method'><a href="module-sequence.html#~group">group</a></li><li data-type='method'><a href="module-sequence.html#~intersperse">intersperse</a></li><li data-type='method'><a href="module-sequence.html#~into">into</a></li><li data-type='method'><a href="module-sequence.html#~iter">iter</a></li><li data-type='method'><a href="module-sequence.html#~join">join</a></li><li data-type='method'><a href="module-sequence.html#~last">last</a></li><li data-type='method'><a href="module-sequence.html#~list">list</a></li><li data-type='method'><a href="module-sequence.html#~lookahead">lookahead</a></li><li data-type='method'><a href="module-sequence.html#~map">map</a></li><li data-type='method'><a href="module-sequence.html#~mapSort">mapSort</a></li><li data-type='method'><a href="module-sequence.html#~mod">mod</a></li><li data-type='method'><a href="module-sequence.html#~next">next</a></li><li data-type='method'><a href="module-sequence.html#~nth">nth</a></li><li data-type='method'><a href="module-sequence.html#~obj">obj</a></li><li data-type='method'><a href="module-sequence.html#~prepend">prepend</a></li><li data-type='method'><a href="module-sequence.html#~product">product</a></li><li data-type='method'><a href="module-sequence.html#~range">range</a></li><li data-type='method'><a href="module-sequence.html#~range0">range0</a></li><li data-type='method'><a href="module-sequence.html#~reject">reject</a></li><li data-type='method'><a href="module-sequence.html#~repeat">repeat</a></li><li data-type='method'><a href="module-sequence.html#~repeatFn">repeatFn</a></li><li data-type='method'><a href="module-sequence.html#~reverse">reverse</a></li><li data-type='method'><a href="module-sequence.html#~second">second</a></li><li data-type='method'><a href="module-sequence.html#~seqEq">seqEq</a></li><li data-type='method'><a href="module-sequence.html#~skip">skip</a></li><li data-type='method'><a href="module-sequence.html#~skipWhile">skipWhile</a></li><li data-type='method'><a href="module-sequence.html#~slidingWindow">slidingWindow</a></li><li data-type='method'><a href="module-sequence.html#~sum">sum</a></li><li data-type='method'><a href="module-sequence.html#~take">take</a></li><li data-type='method'><a href="module-sequence.html#~takeDef">takeDef</a></li><li data-type='method'><a href="module-sequence.html#~takeUntil">takeUntil</a></li><li data-type='method'><a href="module-sequence.html#~takeUntilVal">takeUntilVal</a></li><li data-type='method'><a href="module-sequence.html#~takeWithFallback">takeWithFallback</a></li><li data-type='method'><a href="module-sequence.html#~tryFind">tryFind</a></li><li data-type='method'><a href="module-sequence.html#~tryFirst">tryFirst</a></li><li data-type='method'><a href="module-sequence.html#~tryLast">tryLast</a></li><li data-type='method'><a href="module-sequence.html#~tryNext">tryNext</a></li><li data-type='method'><a href="module-sequence.html#~tryNth">tryNth</a></li><li data-type='method'><a href="module-sequence.html#~trySecond">trySecond</a></li><li data-type='method'><a href="module-sequence.html#~trySkip">trySkip</a></li><li data-type='method'><a href="module-sequence.html#~trySlidingWindow">trySlidingWindow</a></li><li data-type='method'><a href="module-sequence.html#~union">union</a></li><li data-type='method'><a href="module-sequence.html#~union2">union2</a></li><li data-type='method'><a href="module-sequence.html#~uniq">uniq</a></li><li data-type='method'><a href="module-sequence.html#~zip">zip</a></li><li data-type='method'><a href="module-sequence.html#~zip2">zip2</a></li><li data-type='method'><a href="module-sequence.html#~zipLeast">zipLeast</a></li><li data-type='method'><a href="module-sequence.html#~zipLeast2">zipLeast2</a></li><li data-type='method'><a href="module-sequence.html#~zipLongest">zipLongest</a></li><li data-type='method'><a href="module-sequence.html#~zipLongest2">zipLongest2</a></li></ul></li><li><a href="module-stdtraits.html">stdtraits</a><ul class='methods'><li data-type='method'><a href="module-stdtraits.html#~assertEquals">assertEquals</a></li><li data-type='method'><a href="module-stdtraits.html#~assertUneq">assertUneq</a></li><li data-type='method'><a href="module-stdtraits.html#~assign">assign</a></li><li data-type='method'><a href="module-stdtraits.html#~deepclone">deepclone</a></li><li data-type='method'><a href="module-stdtraits.html#~del">del</a></li><li data-type='method'><a href="module-stdtraits.html#~empty">empty</a></li><li data-type='method'><a href="module-stdtraits.html#~eq">eq</a></li><li data-type='method'><a href="module-stdtraits.html#~get">get</a></li><li data-type='method'><a href="module-stdtraits.html#~has">has</a></li><li data-type='method'><a href="module-stdtraits.html#~isImmutable">isImmutable</a></li><li data-type='method'><a href="module-stdtraits.html#~keys">keys</a></li><li data-type='method'><a href="module-stdtraits.html#~pairs">pairs</a></li><li data-type='method'><a href="module-stdtraits.html#~replace">replace</a></li><li data-type='method'><a href="module-stdtraits.html#~setdefault">setdefault</a></li><li data-type='method'><a href="module-stdtraits.html#~shallowclone">shallowclone</a></li><li data-type='method'><a href="module-stdtraits.html#~size">size</a></li><li data-type='method'><a href="module-stdtraits.html#~typeIsImmutable">typeIsImmutable</a></li><li data-type='method'><a href="module-stdtraits.html#~uneq">uneq</a></li><li data-type='method'><a href="module-stdtraits.html#~values">values</a></li></ul></li><li><a href="module-trait.html">trait</a><ul class='methods'><li data-type='method'><a href="module-trait.html#~supports">supports</a></li><li data-type='method'><a href="module-trait.html#~valueSupports">valueSupports</a></li></ul></li><li><a href="module-typesafe.html">typesafe</a><ul class='methods'><li data-type='method'><a href="module-typesafe.html#~builder">builder</a></li><li data-type='method'><a href="module-typesafe.html#~create">create</a></li><li data-type='method'><a href="module-typesafe.html#~createFrom">createFrom</a></li><li data-type='method'><a href="module-typesafe.html#~ifdef">ifdef</a></li><li data-type='method'><a href="module-typesafe.html#~isdef">isdef</a></li><li data-type='method'><a href="module-typesafe.html#~isPrimitive">isPrimitive</a></li><li data-type='method'><a href="module-typesafe.html#~type">type</a></li><li data-type='method'><a href="module-typesafe.html#~typename">typename</a></li></ul></li></ul><h3>Interfaces</h3><ul><li><a href="module-hashing-Hashable.html">Hashable</a></li><li><a href="module-hashing-Hasher.html">Hasher</a></li><li><a href="module-sequence-Into.html">Into</a></li><li><a href="module-sequence-Sequence.html">Sequence</a></li><li><a href="module-stdtraits-Assign.html">Assign</a></li><li><a href="module-stdtraits-Deepclone.html">Deepclone</a></li><li><a href="module-stdtraits-Delete.html">Delete</a></li><li><a href="module-stdtraits-Equals.html">Equals</a></li><li><a href="module-stdtraits-Get.html">Get</a></li><li><a href="module-stdtraits-Has.html">Has</a></li><li><a href="module-stdtraits-Immutable.html">Immutable</a></li><li><a href="module-stdtraits-Pairs.html">Pairs</a></li><li><a href="module-stdtraits-Replace.html">Replace</a></li><li><a href="module-stdtraits-Setdefault.html">Setdefault</a></li><li><a href="module-stdtraits-Shallowclone.html">Shallowclone</a></li><li><a href="module-stdtraits-Size.html">Size</a></li></ul><h3>Global</h3><ul><li><a href="global.html#flatten">flatten</a></li><li><a href="global.html#multiline">multiline</a></li><li><a href="global.html#takeShort">takeShort</a></li></ul>
</nav>

<div id="main">
    

    



    


    <section class="package">
        <h3>ferrum 1.9.0</h3>		
    </section>









    



    <section class="readme usertext">
        <article><p><a name="ferrum"></a></p>
<h1>Ferrum</h1>
<p>Features from the Rust language in JavaScript: Provides <a href="https://doc.rust-lang.org/rust-by-example/trait.html">Traits</a> &amp; an advanced library for working with sequences/iterators in JS.</p>
<p><a href="https://github.com/adobe/ferrum">Github</a><br>
<a href="https://www.ferrumjs.org">API Documentation</a></p>
<p><a name="table-of-contents"></a></p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#ferrum">Ferrum</a>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#status">Status</a></li>
<li><a href="#usage--features">Usage &amp; Features</a>
<ul>
<li><a href="#hashing">Hashing</a></li>
<li><a href="#doctest">Testing of examples in Documentation</a></li>
<li><a href="#sequenceiterators">Sequence/Iterators</a>
<ul>
<li><a href="#objects-as-sequences">Objects as Sequences</a></li>
<li><a href="#reverse-currying">Reverse Currying</a></li>
<li><a href="#pipelining">Pipelining</a></li>
<li><a href="#lazy-evaluation">Lazy Evaluation</a></li>
</ul>
</li>
<li><a href="#traits">Traits</a></li>
<li><a href="#operators-as-functions">Operators as functions</a></li>
<li><a href="#typing-utilities">Typing utilities</a></li>
<li><a href="#functional-utilities">Functional Utilities</a></li>
</ul>
</li>
<li><a href="#change-log">Change Log</a>
<ul>
<li><a href="#180">1.8.0</a></li>
<li><a href="#170">1.7.0</a></li>
<li><a href="#160">1.6.0</a></li>
<li><a href="#150">1.5.0</a></li>
<li><a href="#140">1.4.0</a></li>
<li><a href="#130">1.3.0</a></li>
<li><a href="#120">1.2.0</a></li>
</ul>
</li>
<li><a href="#development">Development</a>
<ul>
<li><a href="#build">Build</a></li>
<li><a href="#test">Test</a></li>
<li><a href="#lint">Lint</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="status"></a></p>
<h2>Status</h2>
<p><a href="https://circleci.com/gh/adobe/ferrum/tree/master"><img src="https://img.shields.io/circleci/project/github/adobe/ferrum/master.svg" alt="CircleCI"></a>
<a href="https://codecov.io/gh/adobe/ferrum"><img src="https://img.shields.io/codecov/c/github/adobe/ferrum.svg" alt="codecov"></a>
<a href="https://github.com/adobe/ferrum/blob/master/LICENSE.txt"><img src="https://img.shields.io/github/license/adobe/ferrum.svg" alt="GitHub license"></a>
<a href="https://github.com/adobe/ferrum/issues"><img src="https://img.shields.io/github/issues/adobe/ferrum.svg" alt="GitHub issues"></a>
<a href="https://lgtm.com/projects/g/adobe/ferrum"><img src="https://img.shields.io/lgtm/grade/javascript/g/adobe/ferrum.svg?logo=lgtm&amp;logoWidth=18" alt="LGTM Code Quality Grade: JavaScript"></a>
<a href="https://github.com/semantic-release/semantic-release"><img src="https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg" alt="semantic-release"></a></p>
<p><a name="usage-features"></a></p>
<h2>Usage &amp; Features</h2>
<pre class="prettyprint source lang-bash,notest"><code>$ npm add ferrum
</code></pre>
<p><a name="hashing"></a></p>
<h3>Hashing &amp; Hash Tables</h3>
<p>Ferrum features an extensible, reliable infrastructure for object hashing
including an implementation of
<a href="https://www.ferrumjs.org/module-hashing-HashMap.html">HashMap</a> and
<a href="https://www.ferrumjs.org/module-hashing-HashSet.html">HashSet</a>.</p>
<p>It supports <a href="">user defined hash functions</a> (e.g. blake2 instead of xxhash).
Support for all of the standard types is provided out of the box and
<a href="https://www.ferrumjs.org/module-hashing-Hashable.html">support for user defined types</a>
or third party types can be provided via the trait infrastructure.</p>
<p>You could even integrate the
<a href="https://www.npmjs.com/package/object-hash">object-hash</a> package to add support
for hashing arbitrary third party types! See &quot;Sophisticated hasher integrating
object hash&quot;  in the
<a href="https://www.ferrumjs.org/module-hashing-Hasher.html">hasher trait</a> documentation.</p>
<pre class="prettyprint source lang-js"><code>const assert = require('assert');
const { HashMap } = require('ferrum');

const m = new Map([[{}, 42], [7, &quot;seven&quot;]]);
assert.strictEqual(m.get(7), &quot;seven&quot;);
assert.strictEqual(m.get({}), undefined); // Identity based lookup

const hm = new HashMap([[{}, 42], [7, &quot;seven&quot;]]);
assert.strictEqual(hm.get(7), &quot;seven&quot;);
assert.strictEqual(hm.get({}), 42); // Content based lookup
</code></pre>
<p><a name="doctest"></a></p>
<h3>Testing of Examples</h3>
<p>Have you ever found out that some of the examples in your api documentation
or readme contained bugs? You can now use the <a href="https://github.com/adobe/ferrum.doctest">Ferrum Doctest</a>
companion package to run your examples as part of your regular test harness!</p>
<p><a name="sequence-iterators"></a></p>
<h3>Sequence/Iterators</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Ferrum</th>
<th>Underscore</th>
<th>Lodash</th>
<th>wu.js</th>
</tr>
</thead>
<tbody>
<tr>
<td>Objects as Sequences</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Reverse Currying</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Lazy Evaluation</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Pipelining</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>Ferrum provides a library for transforming lists &amp; iterables; it provides all the functions
you would expect like <code>map</code>, <code>filter</code>, <code>foldl</code> and many others. In this regard it is very similar
to libraries like wu.js, lodash or underscore. Ferrum has been written to remedy some of the issues
in these libraries.</p>
<p><a name="objects-as-sequences"></a></p>
<h4>Objects as Sequences</h4>
<p><code>Ferrum/Sequence</code> has been designed with full iterator support in mind. Generally all functions
can take iterables/iterators and returns iterators.</p>
<pre class="prettyprint source lang-js"><code>const {map, assertSequenceEquals} = require('ferrum');

const a = map([1,2,3,4], x => x+2); // a is an iterator
const b = map(a, x => x*2); // b is also an iterator
assertSequenceEquals(b, [6, 8, 10, 12]);
</code></pre>
<p>In addition to supporting iterables &amp; iterators, <code>Ferrum/Sequence</code> can take objects as input:</p>
<pre class="prettyprint source lang-js"><code>const {map,  iter, assertEquals, assertSequenceEquals} = require('ferrum');

const a = map({a: 42, b: 43}, ([k, v]) => v+2); // a is an iterator
const b = map(a, x => x*2); // b is also an iterator
assertSequenceEquals(b, [88, 90]);

const obj = {foo: 23, bar: 24};
const log = [];
for (const [key, value] of iter(obj)) {
  log.push(`${key} | ${value}`);
}

assertEquals(log, [
  'foo | 23',
  'bar | 24',
]);
</code></pre>
<p><code>Ferrum/Sequence</code> uses <a href="https://lodash.com/docs/4.17.11#isPlainObject">lodash.isPlainObject</a>
and always tries to use the iterator protocol to make sure object iteration is only used if
it really should.</p>
<pre class="prettyprint source lang-js"><code>const {map, assertSequenceEquals} = require('ferrum');

const obj = {};
obj[Symbol.iterator] = function*() {
  yield 2;
  yield 3;
};

assertSequenceEquals(map(obj, x => x*2), [4, 6]);
</code></pre>
<p><code>Lodash</code> and <code>Underscore</code> only support arrays as input &amp; output; <code>wu.js</code> supports iterators as input &amp; output but has no
support for plain objects.</p>
<p><a name="reverse-currying"></a></p>
<h4>Reverse Currying</h4>
<p><code>Ferrum/Sequence</code> provides many higher order functions. These are functions that take other functions as parameters, like <code>map()</code> or <code>filter()</code>.</p>
<pre class="prettyprint source lang-js"><code>const {map, filter, assertSequenceEquals} = require('ferrum');

// Map is used to change each value in a list/iterable
assertSequenceEquals(map([1,2,3,4], x => x*2), [2,4,6,8]);

// Filter removes elements in a list/iterable
assertSequenceEquals(filter([1,2,3,4], x => x%2 === 0), [2, 4]);
</code></pre>
<p>Sometimes it can be useful to create an intermediate function with just a
few arguments instead of calling the function right away:</p>
<pre class="prettyprint source lang-js"><code>const { map, plus, list, assertSequenceEquals } = require('ferrum');

const myList = [
  [1,2,3],
  [4,5,6],
  [7,8,9]
];

// Add 2 to each number in a two dimensional list
// This example uses currying twice: in the `plus(2)`
// and in the `map()`
const a = map(myList, map(plus(2)));
assertSequenceEquals(map(a, list), [
  [3,4,5],
  [6,7,8],
  [9,10,11]
]);

// This is what the code would look like without currying:
// A lot less convenient and harder to read
const b = map(myList, (sublist) => map(sublist, (b) => plus(b, 2)));
assertSequenceEquals(map(b, list), [
  [3,4,5],
  [6,7,8],
  [9,10,11]
]);
</code></pre>
<p>You may have noticed, that when currying is used, the arguments are given in reverse order; this is
why we call it reverse currying. We have decided to use currying this way, because there should never
be extra arguments after the function (otherwise you end up with dangling arguments multiple lines below)
while the function is usually also the first parameter you want to supply when currying:</p>
<pre class="prettyprint source lang-js,notest"><code>// This is not very handy because you might need to scroll down to find the last
// argument; you will also need to scroll down to determine whether the call to
// each is using currying
each(() => {
  ...
}, [1,2,3]);

// This is much more handy
each([1,2,3], () => {
  ...
});
</code></pre>
<p>Underscore.js does not support currying at all; lodash provides curried variants of their functions in an extra
module (not very handy either because it is often useful to mix curried and non currying invocations) while lodash
has opted to make the function the first parameter, delivering good support for currying and not so good support
for normal function invocation.</p>
<p><a name="pipelining"></a></p>
<h4>Pipelining</h4>
<p><code>Ferrum</code> provides a function called <code>pipe()</code> which – together with currying – can be used to build complex data processing pipelines.
Pipelines are conceptually the same as the highly successful pipes in bash; the feature is currently being introduced into the JavaScript
standard library in the form of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Pipeline_operator"><code>|&gt;</code> operator</a>.</p>
<pre class="prettyprint source lang-js"><code>const { sqrt, floor } = Math;
const {
  pipe, filter, uniq, map, mul, mapSort, identity, take,
  prepend, takeWhile, all, range, assertSequenceEquals,
  extend, plus, any,
} = require('ferrum');

const a = pipe(
  [5,1,6,7,10,11,1,3,4],
  filter(x => x%2 === 1), // Get rid of even number
  uniq,                   // Get rid of duplicates
  map(mul(3)),            // Multiply each element by three
  mapSort(identity));     // Sort all numbers
assertSequenceEquals(a, [3,9,15,21,33]);

// Very simple primality test
const isPrime = (v) => v > 1 && pipe(
  range(2, floor(sqrt(v)) + 1),
  map(x => v % x !== 0), // check that v is not divisible by x
  all);

// Sequence of all prime numbers (calculated slowly)
const primes = () => pipe(
  range(0, Infinity),
  filter(isPrime));

assertSequenceEquals(take(primes(), 5), [2, 3, 5, 7, 11]);
</code></pre>
<p>Learning to write algorithms in this way is not always easy, but it can be very rewarding
as the pipe form is often a lot more readable. To illustrate this, let's take a look how our
code of the prime sequence example changes as we take a way features from <code>Ferrum</code>;
let's first take away currying and the <code>pipe()</code> function itself:</p>
<pre class="prettyprint source lang-js"><code>const { sqrt, floor } = Math;
const { all, map, takeWhile, filter, range, assertSequenceEquals, take, extend, plus } = require('ferrum');

const isPrime = (v) => v > 1 && all(map(range(2, floor(sqrt(v))+1), x => v % x !== 0));
const primes = () => filter(range(0, Infinity), isPrime);

assertSequenceEquals(take(primes(), 5), [2, 3, 5, 7, 11]);
</code></pre>
<p>One way to work around the lack of currying and <code>pipe()</code> is to just put all our
filter stages into one expression. Due to this, our code has become much shorter and much harder to read.
Look at how the dataflow jumps around, see how distant the map function and it's argument are from each other
and it does not help that subexpression cannot be properly documented any more.
Let's try another way to write down these functions:</p>
<pre class="prettyprint source lang-js"><code>const { sqrt, floor } = Math;
const { assertSequenceEquals, all, map, takeWhile, filter, range, take } = require('ferrum');

const integers = () => range(1, Infinity);
const isPrime = (v) => {
  const candidates = range(2, floor(sqrt(v)) + 1);
  const tests = map(candidates, x => v % x !== 0)
  return v > 1 && all(tests);
}
const primes = () => filter(integers(), isPrime);

assertSequenceEquals(take(primes(), 5), [2, 3, 5, 7, 11]);
</code></pre>
<p>This is much better! The data flow is more clear and substeps can be documented again.
In this version we used temporary variables to get around not having <code>pipe()</code> and currying;
this is much better than just putting everything into one line.</p>
<p>Note how <code>positiveIntegers</code> became its own function while <code>fromTwo</code> and <code>candidates</code>
became just local variables. Also note how <code>all</code> and <code>map</code> are still in the same expression.
Sometimes this is the more readable variant. We have to decide each time.</p>
<p>This variant still has disadvantages though; first of all the code still looks more
cluttered and the dataflow still jumps around more than the pipe variant.
You also have to come up with a lot of names for temporary variables and take care
not to reuse them (since they are lazily evaluated they must only be used once).
This is one of the things you communicate by using <code>pipe()</code> over local variables: &quot;This variable
will never be used again&quot; – knowing this &amp; limiting the number of variables in a scope can be
very useful, especially in large functions.</p>
<p>Finally, let's implement this in classic imperative style:</p>
<pre class="prettyprint source lang-js"><code>const { sqrt } = Math;

const isPrime = (v) => {
  if (v &lt; 2) {
    return false;
  }

  for (let i=0; i &lt;= sqrt(v); i++) {
    if (v % i !== 0) {
      return false;
    }
  }

  return true;
}

const primes = function *primes() {
  for (let i=0; true; i++) {
    if (isPrime(i)) {
      yield i;
    }
  }
}
</code></pre>
<p>The first thing that becomes noticeable in this version is that it is more
than twice as long as our variant using <code>pipe()</code> (not counting comment lines);
this version also uses two levels of nesting, while our pipelined version uses
just one level of nesting. The imperative version also contains two for loops
and three if statements; for loops are notoriously hard to read as well.
Finally, the imperative version forces us to think in imperative terms – to consider
what happens in each step of the for loop one by one and then come to the conclusion:
<em>Ah, this for loop just gets rid of all those integers that are not prime</em>. In the imperative
version this intention must be deduced, in the pipelined version it is plain to see.</p>
<p>To sum it up, using <code>pipe()</code> and currying the functions from <code>Ferrum</code> has a number
of advantages; you end up with fewer levels of nesting, can avoid a lot of branching (if statements)
and hard to write for loops; pipelining let's you break apart your problem into multiple
clearly defined transformation steps with obvious data flow and obvious intention.</p>
<p>Underscore, lodash and wu.js all allow you to do something similar with chaining which does work quite well.
They do require a bit more boilerplate since values need to be wrapped before chaining and unwrapped
after chaining has finished. Pipelining will have even less boilerplate when the <code>|&gt;</code> becomes
available and pipelining can be used with arbitrary transformation functions, while
chaining can only be used with functions supported by the library, thus pipelining is much
more generic &amp; extensible.</p>
<p><a name="lazy-evaluation"></a></p>
<h4>Lazy Evaluation</h4>
<p>Like Python iterators, sequences support lazy evaluation. They support it, because lazy evaluation
is a core feature of JavaScript ES6 iterators.</p>
<p>This means that the values in iterators/sequences are only evaluated once they
are needed:</p>
<pre class="prettyprint source lang-js"><code>const { map, plus, list, assertSequenceEquals } = require('ferrum');
const a = map([1,2,3], plus(2)); // At this point, no calculations have been performed
const b = list(a); // This will actually cause the values of the `a` iterator to be calculatedA
assertSequenceEquals(a, []); // `a` is now exhausted and can no longer be used
assertSequenceEquals(b, [3,4,5]); // `b` can be used as often as we want
assertSequenceEquals(b, [3,4,5]);
</code></pre>
<p>Try the above example with a couple of <code>console.log</code> statements and see what happens.</p>
<p>The practical upshot of this property is that it becomes possible to work with infinite
sequences, like the <code>primes()</code> sequence above. It can be more efficient as well, since
values that are not needed are not computed.</p>
<pre class="prettyprint source lang-js"><code>const {take, list, assertSequenceEquals} = require('ferrum');

function* fibonacci() {
  let a=0, b=1;
  while (true) {
    yield a;
    yield b;
    a += b;
    b += a;
  }
}

// Even though fibonacci() is infinite, this just works because only the
// first five fibonacci numbers are actually generated
// Note that just list(fibonacci()) would crash the program since that would
// require infinite memory and infinite time
assertSequenceEquals(take(fibonacci(), 5), [0, 1, 1, 2, 3]);
</code></pre>
<p>Underscore and lodash use arrays instead of iterators, so they have no lazy evaluation support.
wu.js uses iterators and thus has full lazy evaluation support.</p>
<p><a name="traits"></a></p>
<h3>Traits</h3>
<p><code>Sequence/Traits</code> is the second big feature this library provides; it is a concept borrowed from
the Rust language. They let you declare &amp; document a generic interface; like the <code>sequence</code> concept
above they are not an entirely new concept; while sequence is a library designed to make working
with the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">JavaScript iteration protocols</a>
easier, traits standardize the creation of JavaScript protocols itself, thereby reducing boilerplate.
Indeed the <code>Sequence</code> Trait is just a wrapper over the <code>Iterable</code> protocol of JavaScript.</p>
<pre class="prettyprint source lang-js"><code>const {Trait} = require('ferrum');

// Declaring a trait
/**
 * The Size trait is used for any containers that have a known size, like
 * arrays, strings, Maps…
 * Size should be used only for sizes that are relatively quick to compute, O(1) optimally…
 * @interface
 */
const Size = new Trait('Size');

// Using it
const size = (what) => Size.invoke(what);
const empty = (what) => size(what) === 0;

// Providing implementations for own types; this implementation will be
// inherited by subclasses
class MyType {
  [Size.sym]() {
    return 42;
  }
}

// Providing implementations for third party types. These won't be inherited
// by subclasses
Size.impl(Array, (x) => x.length); // Method of type Array
Size.impl(String, (x) => x.length);
Size.impl(Map, (x) => x.size);
Size.impl(Set, (x) => x.size);

// This implementation just applies to plain objects.
Size.impl(Object, (x) => {
  let cnt = 0;
  for (const _ in x) cnt++;
  return cnt;
});

// Note: The two following examples would be a bad idea in reality,
// they are just here toshow the mechanism
Size.implStatic(null, (_) => 0); // Static implementation (for a value and not a type)
</code></pre>
<p>Some of the advantages of using Traits are illustrated for the code above:
First of all, using traits saves us a bit of boilerplate code; by having an actual
variable representing the trait, we have a good place to document the trait; the <code>@interface</code>
jsdoc feature can be used for this. We can also use this documentation to specify laws that
implementations of the trait should abide by, like the (soft) law that <code>Size</code> implementations
should be quick to compute.</p>
<p>Trait also features machinery to implement traits for third party types and even built in types
like <code>Array</code>, <code>Object</code>, <code>null</code> or <code>undefined</code>. The classic way to implement protocols does not work in these
cases:</p>
<pre class="prettyprint source lang-js"><code>const Size = Symbol('Size');

// Using just Symbols works perfectly for your own types
class MyType {
  [Size]() {
    return 42;
  }
}

// Using symbols for third party types is suboptimal,
// since we have to modify the type's prototype which
// could lead to weirdness
Array.prototype[Size] = () => this.length;

// Using symbols for Object, is a very bad idea as the implementation
// will be inherited by all other classes…this implementation obviously
// is the wrong one for Set for instance.
// This also illustrates why it is generally a bad idea to enable inheritance
// for third party types
Object.prototype[Size] = () => {
  let cnt = 0;
  for (const _ in this) cnt++;
  return cnt;
}

// Using symbols on values like null or undefined will just lead to a TypeError
// being thrown

//null[Size] = () => 0; // throws TypeError
</code></pre>
<p>The oldest pre-ES6 implementation just used method names; this strategy is very
problematic, since two different interfaces may use the same method name:</p>
<pre class="prettyprint source lang-js"><code>class MyDbTable {
  size() {
    return request(`https://mydb.com/${this._tableName}/size`);
  }
};

class MyLocalTable {
  size() {
    return this._payload.length;
  }
}
</code></pre>
<p>In the hypothetical example above, one size() method returns an integer, while
the other returns a promise resolving an integer (which makes total sense since
it's the size of some database table). Even though each method makes sense for itself,
there is no way to distinguish between them; the developer may write a function, expecting an integer…</p>
<p>Since the method name <code>size()</code> is already taken, we cannot even implement the async
size interface for <code>MyLocalTable</code>.</p>
<p>Using traits we can actually encapsulate this relationship well:</p>
<pre class="prettyprint source lang-js"><code>// dbtable.js
const { Trait, Size: SyncSize } = require('ferrum');
const Size = new Trait('Size');

class DbTable {
  [Size.sym]() {
    return request(`https://mydb.com/${this._tableName}/size`);
  }
};

class MyLocalTable {
  [Size.sym]() {
    return this._payload.length;
  }
}

Size.implDerived([SyncSize], ([size], v) => Promise.resolve(size(v)));
</code></pre>
<p>This example above illustrates how – using traits – we can not only deal with
name collisions by just renaming traits on the fly, we were also able to write
a generic adapter that automatically implements <code>AsyncSize</code> for all types supporting <code>Size</code>.</p>
<p>To sum up, using Traits provides a number of advantages: Traits let you avoid
some boilerplate code, they allow you to specify and implement generic interfaces
without the danger of name collisions; they let you provide implementations for third
party types, built-in types and even <code>null</code>, <code>undefined</code> and plain <code>Object</code> without
modifying these types.
They even let you write generic adapters, implementing traits for entire groups
of traits at once.</p>
<p><a name="operators-as-functions"></a></p>
<h3>Operators as functions</h3>
<p><code>Ferrum/Ops</code> provides all of the JS operators and some extra boolean operators as curryable functions.</p>
<pre class="prettyprint source lang-js"><code>const { strictEqual: assertIs } = require('assert');
const { plus, and, not, is, xor, map, list, assertSequenceEquals } = require('ferrum');

assertSequenceEquals(
  map([1,2,3], plus(2)),   /* => */ [3,4,5]);
assertIs(and(true, false), /* => */ false);
assertIs(not(1),           /* => */ false);
assertIs(is(2, 2),         /* => */ true);
assertIs(xor(true, false), /* => */ true);
</code></pre>
<p><a name="typing-utilities"></a></p>
<h3>Typing utilities</h3>
<p>Ferrum provides utilities for working with types that can be safely
used with null and undefined.</p>
<pre class="prettyprint source lang-js"><code>const { strictEqual: assertIs } = require('assert');
const {isdef, type, typename} = require('ferrum');

assertIs(isdef(0),         /* => */ true);
assertIs(isdef(null),      /* => */ false);
assertIs(isdef(undefined), /* => */ false);

assertIs(type(22),        /* => */ Number);
assertIs(type(null),      /* => */ null);
assertIs(type(undefined), /* => */ undefined);

assertIs(typename(type(22)),        /* => */ &quot;Number&quot;);
assertIs(typename(type(null)),      /* => */ &quot;null&quot;);
assertIs(typename(type(undefined)), /* => */ &quot;undefined&quot;);
</code></pre>
<p>The usual strategy of using <code>value.constructor</code> and <code>value.constructor.name</code>
yields errors for <code>null</code> &amp; <code>undefined</code>.</p>
<p><a name="functional-utilities"></a></p>
<h3>Functional Utilities</h3>
<pre class="prettyprint source lang-js"><code>const {
  curry, pipe, filter, isdef, uniq, map, plus,
  assertSequenceEquals, assertEquals,
} = require('ferrum');

// Using pipe() + auto currying instead of chaining
assertSequenceEquals(
  pipe(
    [0, 1, 2, null, 3, 4, null, 5, 1, 3, 2, null, 1, 4],
    filter(isdef), // Filter out every null & undefined
    uniq,          // Remove duplicates
    map(plus(2))), // Add two to each element
  /* => */ [2, 3, 4, 5, 6, 7]);

// Auto currying
const pair = curry('pair', (a, b) => [a, b]);
assertEquals(pair(1,2),  /* => */ [1,2]);
assertEquals(pair(2)(1), /* => */ [1,2]);
</code></pre>
<p><a name="changelog"></a></p>
<h2>Change Log</h2>
<h3>Features</h3>
<h3>1.9.0</h3>
<ul>
<li>Hashable Trait &amp; Hash tables (<a href="https://github.com/adobe/ferrum/commit/3a86070336d9a7f165e1d1d15b7858a0c1391c89">3a86070</a>)</li>
<li>apply1(), let_in(), call() (<a href="https://github.com/adobe/ferrum/commit/3a86070336d9a7f165e1d1d15b7858a0c1391c89">3a86070</a>)</li>
<li>create(), createFrom(), builder() (<a href="https://github.com/adobe/ferrum/commit/3a86070336d9a7f165e1d1d15b7858a0c1391c89">3a86070</a>)</li>
</ul>
<h3>1.8.0</h3>
<ul>
<li>Move many tests into the documentation examples (<a href="https://github.com/adobe/ferrum/commit/c033897fc9bc224">c033897</a>)</li>
</ul>
<h3>1.7.0</h3>
<ul>
<li>Use ferrum.doctest to make sure examples are valid js code (<a href="https://github.com/adobe/ferrum/commit/b0f9d45">b0f9d45</a>)</li>
</ul>
<h3>1.6.0</h3>
<ul>
<li>Add mutate(), apply() (<a href="https://github.com/adobe/ferrum/commit/d4e3a7a750afe58696097b5f75117c555291d01b">8d28f73</a>)</li>
</ul>
<h3>1.5.0</h3>
<ul>
<li>Alias flatten() -&gt; flat() (<a href="https://github.com/adobe/ferrum/commit/2abad3f4cc72bbad7ee19da8f59d4917">2abad3f</a>)</li>
<li>group(), multiline() and takeUntil() (<a href="https://github.com/adobe/ferrum/commit/0bc0ca0059b6a7f8f61cf">0bc0ca0</a>)</li>
</ul>
<h3>1.4.0</h3>
<ul>
<li>Add intersperse() (<a href="https://github.com/adobe/ferrum/commit/8d28f73">8d28f73</a>)</li>
</ul>
<h3>1.3.0</h3>
<ul>
<li>Add function repeatFn() (<a href="https://github.com/adobe/ferrum/commit/81de232">81de232</a>)</li>
<li>Provide chunkify functions (<a href="https://github.com/adobe/ferrum/commit/9ff9603">9ff9603</a>)</li>
<li>Provide takeShort() &amp; takeWithFallback() (<a href="https://github.com/adobe/ferrum/commit/bafa834">bafa834</a>)</li>
<li>slidingWindow now returns an empty sequence if no=0 (<a href="https://github.com/adobe/ferrum/commit/533cff4">533cff4</a>)</li>
</ul>
<h3>1.2.0</h3>
<ul>
<li><strong>Bugfix: Support for objects with Symbol keys</strong> – Before this change
most functions would disregard Symbol keys in objects. E.g. <code>size({[Symbol()]: 42})</code>
would return zero. Now the functions
<code>pairs(), keys(), values(), size(), empty(), shallowclone(), deepclone(), iter(),  each(), replace(), setdefault(), del(), assign(), has(), get(), eq, uneq,  assertEquals, assertUneq</code> are explicitly tested and with objects containing symbol keys.</li>
</ul>
<p><a name="development"></a></p>
<h2>Development</h2>
<p><a name="build"></a></p>
<h3>Build</h3>
<pre class="prettyprint source lang-bash,notest"><code>$ npm install
</code></pre>
<p><a name="test"></a></p>
<h3>Test</h3>
<pre class="prettyprint source lang-bash,notest"><code>$ npm test
</code></pre>
<p><a name="lint"></a></p>
<h3>Lint</h3>
<pre class="prettyprint source lang-bash,notest"><code>$ npm run lint
</code></pre></article>
    </section>






    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Fri Apr 16 2021 16:48:42 GMT+0200 (Central European Summer Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>