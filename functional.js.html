<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>functional.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-hashing-DefaultHasher.html">DefaultHasher</a><ul class='methods'><li data-type='method'><a href="module-hashing-DefaultHasher.html#.fromSeed">fromSeed</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#.new">new</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#.withOpts">withOpts</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#buildHasher">buildHasher</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#digest">digest</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#update">update</a></li></ul></li><li><a href="module-hashing-HashMap.html">HashMap</a><ul class='methods'><li data-type='method'><a href="module-hashing-HashMap.html#.fromSeq">fromSeq</a></li><li data-type='method'><a href="module-hashing-HashMap.html#.fromSeqWithOpts">fromSeqWithOpts</a></li><li data-type='method'><a href="module-hashing-HashMap.html#.new">new</a></li><li data-type='method'><a href="module-hashing-HashMap.html#clear">clear</a></li><li data-type='method'><a href="module-hashing-HashMap.html#delete">delete</a></li><li data-type='method'><a href="module-hashing-HashMap.html#entries">entries</a></li><li data-type='method'><a href="module-hashing-HashMap.html#forEach">forEach</a></li><li data-type='method'><a href="module-hashing-HashMap.html#get">get</a></li><li data-type='method'><a href="module-hashing-HashMap.html#getPair">getPair</a></li><li data-type='method'><a href="module-hashing-HashMap.html#has">has</a></li><li data-type='method'><a href="module-hashing-HashMap.html#keys">keys</a></li><li data-type='method'><a href="module-hashing-HashMap.html#set">set</a></li><li data-type='method'><a href="module-hashing-HashMap.html#size">size</a></li><li data-type='method'><a href="module-hashing-HashMap.html#values">values</a></li></ul></li><li><a href="module-hashing-HashSet.html">HashSet</a><ul class='methods'><li data-type='method'><a href="module-hashing-HashSet.html#.fromSeq">fromSeq</a></li><li data-type='method'><a href="module-hashing-HashSet.html#.fromSeqWithOpts">fromSeqWithOpts</a></li><li data-type='method'><a href="module-hashing-HashSet.html#.new">new</a></li><li data-type='method'><a href="module-hashing-HashSet.html#add">add</a></li><li data-type='method'><a href="module-hashing-HashSet.html#clear">clear</a></li><li data-type='method'><a href="module-hashing-HashSet.html#delete">delete</a></li><li data-type='method'><a href="module-hashing-HashSet.html#entries">entries</a></li><li data-type='method'><a href="module-hashing-HashSet.html#forEach">forEach</a></li><li data-type='method'><a href="module-hashing-HashSet.html#get">get</a></li><li data-type='method'><a href="module-hashing-HashSet.html#has">has</a></li><li data-type='method'><a href="module-hashing-HashSet.html#size">size</a></li><li data-type='method'><a href="module-hashing-HashSet.html#values">values</a></li></ul></li><li><a href="module-hashing-UnorderedHasher.html">UnorderedHasher</a><ul class='methods'><li data-type='method'><a href="module-hashing-UnorderedHasher.html#.fromBuildHasher">fromBuildHasher</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#.new">new</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#.withOpts">withOpts</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#buildHasher">buildHasher</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#digest">digest</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#update">update</a></li></ul></li><li><a href="module-trait-HybridWeakMap.html">HybridWeakMap</a></li><li><a href="module-trait-Trait.html">Trait</a><ul class='methods'><li data-type='method'><a href="module-trait-Trait.html#impl">impl</a></li><li data-type='method'><a href="module-trait-Trait.html#implDerived">implDerived</a></li><li data-type='method'><a href="module-trait-Trait.html#implStatic">implStatic</a></li><li data-type='method'><a href="module-trait-Trait.html#implWild">implWild</a></li><li data-type='method'><a href="module-trait-Trait.html#implWildStatic">implWildStatic</a></li><li data-type='method'><a href="module-trait-Trait.html#invoke">invoke</a></li><li data-type='method'><a href="module-trait-Trait.html#lookupType">lookupType</a></li><li data-type='method'><a href="module-trait-Trait.html#lookupValue">lookupValue</a></li></ul></li><li><a href="module-trait-TraitNotImplemented.html">TraitNotImplemented</a></li></ul><h3>Modules</h3><ul><li><a href="module-functional.html">functional</a><ul class='methods'><li data-type='method'><a href="module-functional.html#~apply">apply</a></li><li data-type='method'><a href="module-functional.html#~apply1">apply1</a></li><li data-type='method'><a href="module-functional.html#~call">call</a></li><li data-type='method'><a href="module-functional.html#~compose">compose</a></li><li data-type='method'><a href="module-functional.html#~curry">curry</a></li><li data-type='method'><a href="module-functional.html#~exec">exec</a></li><li data-type='method'><a href="module-functional.html#~identity">identity</a></li><li data-type='method'><a href="module-functional.html#~let_in">let_in</a></li><li data-type='method'><a href="module-functional.html#~pipe">pipe</a></li><li data-type='method'><a href="module-functional.html#~withFunctionName">withFunctionName</a></li></ul></li><li><a href="module-hashing.html">hashing</a><ul class='methods'><li data-type='method'><a href="module-hashing.html#~bytes2hex">bytes2hex</a></li><li data-type='method'><a href="module-hashing.html#~defaultBuildHasher">defaultBuildHasher</a></li><li data-type='method'><a href="module-hashing.html#~hash">hash</a></li><li data-type='method'><a href="module-hashing.html#~hashDirectly">hashDirectly</a></li><li data-type='method'><a href="module-hashing.html#~hashmap">hashmap</a></li><li data-type='method'><a href="module-hashing.html#~hashSeq">hashSeq</a></li><li data-type='method'><a href="module-hashing.html#~hashSeqWith">hashSeqWith</a></li><li data-type='method'><a href="module-hashing.html#~hashset">hashset</a></li><li data-type='method'><a href="module-hashing.html#~hashUnordered">hashUnordered</a></li><li data-type='method'><a href="module-hashing.html#~hashUnorderedWith">hashUnorderedWith</a></li><li data-type='method'><a href="module-hashing.html#~hashWith">hashWith</a></li><li data-type='method'><a href="module-hashing.html#~hex2bytes">hex2bytes</a></li><li data-type='method'><a href="module-hashing.html#~randomBuildHasher">randomBuildHasher</a></li><li data-type='method'><a href="module-hashing.html#~seededBuildHasher">seededBuildHasher</a></li><li data-type='method'><a href="module-hashing.html#~unorderedBuildHasher">unorderedBuildHasher</a></li></ul></li><li><a href="module-op.html">op</a><ul class='methods'><li data-type='method'><a href="module-op.html#~aint">aint</a></li><li data-type='method'><a href="module-op.html#~and">and</a></li><li data-type='method'><a href="module-op.html#~is">is</a></li><li data-type='method'><a href="module-op.html#~mul">mul</a></li><li data-type='method'><a href="module-op.html#~nand">nand</a></li><li data-type='method'><a href="module-op.html#~nor">nor</a></li><li data-type='method'><a href="module-op.html#~not">not</a></li><li data-type='method'><a href="module-op.html#~or">or</a></li><li data-type='method'><a href="module-op.html#~plus">plus</a></li><li data-type='method'><a href="module-op.html#~xnor">xnor</a></li><li data-type='method'><a href="module-op.html#~xor">xor</a></li></ul></li><li><a href="module-sequence.html">sequence</a><ul class='methods'><li data-type='method'><a href="module-sequence.html#~all">all</a></li><li data-type='method'><a href="module-sequence.html#~any">any</a></li><li data-type='method'><a href="module-sequence.html#~append">append</a></li><li data-type='method'><a href="module-sequence.html#~assertSequenceEquals">assertSequenceEquals</a></li><li data-type='method'><a href="module-sequence.html#~cartesian">cartesian</a></li><li data-type='method'><a href="module-sequence.html#~cartesian2">cartesian2</a></li><li data-type='method'><a href="module-sequence.html#~chunkify">chunkify</a></li><li data-type='method'><a href="module-sequence.html#~chunkifyShort">chunkifyShort</a></li><li data-type='method'><a href="module-sequence.html#~chunkifyWithFallback">chunkifyWithFallback</a></li><li data-type='method'><a href="module-sequence.html#~concat">concat</a></li><li data-type='method'><a href="module-sequence.html#~contains">contains</a></li><li data-type='method'><a href="module-sequence.html#~count">count</a></li><li data-type='method'><a href="module-sequence.html#~dict">dict</a></li><li data-type='method'><a href="module-sequence.html#~each">each</a></li><li data-type='method'><a href="module-sequence.html#~enumerate">enumerate</a></li><li data-type='method'><a href="module-sequence.html#~extend">extend</a></li><li data-type='method'><a href="module-sequence.html#~extend1">extend1</a></li><li data-type='method'><a href="module-sequence.html#~filter">filter</a></li><li data-type='method'><a href="module-sequence.html#~find">find</a></li><li data-type='method'><a href="module-sequence.html#~first">first</a></li><li data-type='method'><a href="module-sequence.html#~flat">flat</a></li><li data-type='method'><a href="module-sequence.html#~flattenTree">flattenTree</a></li><li data-type='method'><a href="module-sequence.html#~foldl">foldl</a></li><li data-type='method'><a href="module-sequence.html#~foldr">foldr</a></li><li data-type='method'><a href="module-sequence.html#~group">group</a></li><li data-type='method'><a href="module-sequence.html#~intersperse">intersperse</a></li><li data-type='method'><a href="module-sequence.html#~into">into</a></li><li data-type='method'><a href="module-sequence.html#~iter">iter</a></li><li data-type='method'><a href="module-sequence.html#~join">join</a></li><li data-type='method'><a href="module-sequence.html#~last">last</a></li><li data-type='method'><a href="module-sequence.html#~list">list</a></li><li data-type='method'><a href="module-sequence.html#~lookahead">lookahead</a></li><li data-type='method'><a href="module-sequence.html#~map">map</a></li><li data-type='method'><a href="module-sequence.html#~mapSort">mapSort</a></li><li data-type='method'><a href="module-sequence.html#~mod">mod</a></li><li data-type='method'><a href="module-sequence.html#~next">next</a></li><li data-type='method'><a href="module-sequence.html#~nth">nth</a></li><li data-type='method'><a href="module-sequence.html#~obj">obj</a></li><li data-type='method'><a href="module-sequence.html#~prepend">prepend</a></li><li data-type='method'><a href="module-sequence.html#~product">product</a></li><li data-type='method'><a href="module-sequence.html#~range">range</a></li><li data-type='method'><a href="module-sequence.html#~range0">range0</a></li><li data-type='method'><a href="module-sequence.html#~reject">reject</a></li><li data-type='method'><a href="module-sequence.html#~repeat">repeat</a></li><li data-type='method'><a href="module-sequence.html#~repeatFn">repeatFn</a></li><li data-type='method'><a href="module-sequence.html#~reverse">reverse</a></li><li data-type='method'><a href="module-sequence.html#~second">second</a></li><li data-type='method'><a href="module-sequence.html#~seqEq">seqEq</a></li><li data-type='method'><a href="module-sequence.html#~skip">skip</a></li><li data-type='method'><a href="module-sequence.html#~skipWhile">skipWhile</a></li><li data-type='method'><a href="module-sequence.html#~slidingWindow">slidingWindow</a></li><li data-type='method'><a href="module-sequence.html#~sum">sum</a></li><li data-type='method'><a href="module-sequence.html#~take">take</a></li><li data-type='method'><a href="module-sequence.html#~takeDef">takeDef</a></li><li data-type='method'><a href="module-sequence.html#~takeUntil">takeUntil</a></li><li data-type='method'><a href="module-sequence.html#~takeUntilVal">takeUntilVal</a></li><li data-type='method'><a href="module-sequence.html#~takeWithFallback">takeWithFallback</a></li><li data-type='method'><a href="module-sequence.html#~tryFind">tryFind</a></li><li data-type='method'><a href="module-sequence.html#~tryFirst">tryFirst</a></li><li data-type='method'><a href="module-sequence.html#~tryLast">tryLast</a></li><li data-type='method'><a href="module-sequence.html#~tryNext">tryNext</a></li><li data-type='method'><a href="module-sequence.html#~tryNth">tryNth</a></li><li data-type='method'><a href="module-sequence.html#~trySecond">trySecond</a></li><li data-type='method'><a href="module-sequence.html#~trySkip">trySkip</a></li><li data-type='method'><a href="module-sequence.html#~trySlidingWindow">trySlidingWindow</a></li><li data-type='method'><a href="module-sequence.html#~union">union</a></li><li data-type='method'><a href="module-sequence.html#~union2">union2</a></li><li data-type='method'><a href="module-sequence.html#~uniq">uniq</a></li><li data-type='method'><a href="module-sequence.html#~zip">zip</a></li><li data-type='method'><a href="module-sequence.html#~zip2">zip2</a></li><li data-type='method'><a href="module-sequence.html#~zipLeast">zipLeast</a></li><li data-type='method'><a href="module-sequence.html#~zipLeast2">zipLeast2</a></li><li data-type='method'><a href="module-sequence.html#~zipLongest">zipLongest</a></li><li data-type='method'><a href="module-sequence.html#~zipLongest2">zipLongest2</a></li></ul></li><li><a href="module-stdtraits.html">stdtraits</a><ul class='methods'><li data-type='method'><a href="module-stdtraits.html#~assertEquals">assertEquals</a></li><li data-type='method'><a href="module-stdtraits.html#~assertUneq">assertUneq</a></li><li data-type='method'><a href="module-stdtraits.html#~assign">assign</a></li><li data-type='method'><a href="module-stdtraits.html#~deepclone">deepclone</a></li><li data-type='method'><a href="module-stdtraits.html#~del">del</a></li><li data-type='method'><a href="module-stdtraits.html#~empty">empty</a></li><li data-type='method'><a href="module-stdtraits.html#~eq">eq</a></li><li data-type='method'><a href="module-stdtraits.html#~get">get</a></li><li data-type='method'><a href="module-stdtraits.html#~has">has</a></li><li data-type='method'><a href="module-stdtraits.html#~isImmutable">isImmutable</a></li><li data-type='method'><a href="module-stdtraits.html#~keys">keys</a></li><li data-type='method'><a href="module-stdtraits.html#~pairs">pairs</a></li><li data-type='method'><a href="module-stdtraits.html#~replace">replace</a></li><li data-type='method'><a href="module-stdtraits.html#~setdefault">setdefault</a></li><li data-type='method'><a href="module-stdtraits.html#~shallowclone">shallowclone</a></li><li data-type='method'><a href="module-stdtraits.html#~size">size</a></li><li data-type='method'><a href="module-stdtraits.html#~typeIsImmutable">typeIsImmutable</a></li><li data-type='method'><a href="module-stdtraits.html#~uneq">uneq</a></li><li data-type='method'><a href="module-stdtraits.html#~values">values</a></li></ul></li><li><a href="module-trait.html">trait</a><ul class='methods'><li data-type='method'><a href="module-trait.html#~supports">supports</a></li><li data-type='method'><a href="module-trait.html#~valueSupports">valueSupports</a></li></ul></li><li><a href="module-typesafe.html">typesafe</a><ul class='methods'><li data-type='method'><a href="module-typesafe.html#~builder">builder</a></li><li data-type='method'><a href="module-typesafe.html#~create">create</a></li><li data-type='method'><a href="module-typesafe.html#~createFrom">createFrom</a></li><li data-type='method'><a href="module-typesafe.html#~ifdef">ifdef</a></li><li data-type='method'><a href="module-typesafe.html#~isdef">isdef</a></li><li data-type='method'><a href="module-typesafe.html#~isPrimitive">isPrimitive</a></li><li data-type='method'><a href="module-typesafe.html#~type">type</a></li><li data-type='method'><a href="module-typesafe.html#~typename">typename</a></li></ul></li></ul><h3>Interfaces</h3><ul><li><a href="module-hashing-Hashable.html">Hashable</a></li><li><a href="module-hashing-Hasher.html">Hasher</a></li><li><a href="module-sequence-Into.html">Into</a></li><li><a href="module-sequence-Sequence.html">Sequence</a></li><li><a href="module-stdtraits-Assign.html">Assign</a></li><li><a href="module-stdtraits-Deepclone.html">Deepclone</a></li><li><a href="module-stdtraits-Delete.html">Delete</a></li><li><a href="module-stdtraits-Equals.html">Equals</a></li><li><a href="module-stdtraits-Get.html">Get</a></li><li><a href="module-stdtraits-Has.html">Has</a></li><li><a href="module-stdtraits-Immutable.html">Immutable</a></li><li><a href="module-stdtraits-Pairs.html">Pairs</a></li><li><a href="module-stdtraits-Replace.html">Replace</a></li><li><a href="module-stdtraits-Setdefault.html">Setdefault</a></li><li><a href="module-stdtraits-Shallowclone.html">Shallowclone</a></li><li><a href="module-stdtraits-Size.html">Size</a></li></ul><h3>Global</h3><ul><li><a href="global.html#flatten">flatten</a></li><li><a href="global.html#multiline">multiline</a></li><li><a href="global.html#takeShort">takeShort</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">functional.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

/**
 * @module functional
 * @description Generic library for functional programming &amp; working with functions.
 */

/**
 * Immediately execute the given function.
 *
 * ```js
 * const { strictEqual: assertIs } = require('assert');
 * const {exec} = require('ferrum');
 *
 * // Normal scopes cannot return values
 * let r;
 * {
 *   let x = 42, y = 5;
 *   r = x + y;
 * }
 * assertIs(r, 47);;
 *
 * // Can be rewritten as
 * const q = exec(() => {
 *   let x = 42, y = 5;
 *   return  x + y;
 * });
 * assertIs(q, 47);;
 * ```
 *
 * @function
 * @param {Function} fn
 * @returns Whatever the given function returns.
 */
const exec = (fn) => fn();

/**
 * Just a function that returns it's argument!
 *
 * ```js
 * const { strictEqual: assertIs } = require('assert');
 * const { assertSequenceEquals, identity, filter } = require('ferrum');
 *
 * assertIs(identity(null), null);
 * assertIs(identity(42),   42);
 *
 * // Identity is sometimes useful in higher order functions like
 * // filter(); this example for instance removes all values from
 * // the list that are falsy
 * assertSequenceEquals(
 *   filter([null, "asd", "", 42], identity),
 *   ["asd", 42]);
 * ```
 *
 * @function
 * @template T
 * @param T {a}
 * @returns {T} The parameter
 */
const identity = (a) => a;

/**
 * Pipeline a value through multiple function calls.
 *
 * ```js
 * const { assertSequenceEquals, pipe, filter, uniq, map, plus, identity } = require('ferrum');
 *
 * // Sometimes you want to use a lot of sequence transformations;
 * // When you nest them this gets very hard to read
 * assertSequenceEquals(
 *   map(
 *     uniq(
 *       filter(
 *         [1, 2, null, 3, 4, null, 5, 1, 3, 2, null, 1, 4],
 *         identity
 *       )
 *     ),
 *     plus(2)),
 *   [3, 4, 5, 6, 7]);
 *
 * // Pipe lets you reformat this complex, nested expression so that
 * // the transformer that is first applied, is mentioned first in the
 * // pipeline. Note that currying is used to make functions like filter
 * // or map work nicely with pipe
 * assertSequenceEquals(
 *   pipe(
 *     [1, 2, null, 3, 4, null, 5, 1, 3, 2, null, 1, 4],
 *     filter(identity),
 *     uniq,
 *     map(plus(2))),
 *   [3, 4, 5, 6, 7]);
 * ```
 *
 * @function
 * @param {*} val The value to pipe through the functions
 * @param {Function} fns Multiple functions
 * @returns {*}
 */
const pipe = (val, ...fns) => fns.reduce((v, fn) => fn(v), val);

/**
 * Function composition.
 *
 * This essentially behaves like `pipe()` without taking the initial argument:
 * executed left-to-right/top-to-bottom.
 *
 * ```js
 * const { strictEqual: assertIs } = require('assert');
 * const { compose, plus, mul } = require('ferrum');
 *
 * const fn = compose(plus(2), mul(3), x => `My Number ${x}`);
 * assertIs(fn(4), 'My Number 18');
 * ```
 *
 * @function
 * @param {Function} fns Multiple functions
 * @returns {Function} All the functions in the sequence composed into one
 */
const compose = (...fns) => (val) => pipe(val, ...fns);

/**
 * Manually assign a name to a function.
 *
 * ```js
 * const { strictEqual: assertIs } = require('assert');
 * const { withFunctionName } = require('ferrum');
 *
 * const fn = () => {};
 * assertIs(fn.name, 'fn');
 *
 * const alias = withFunctionName('foo', fn)
 * assertIs(fn.name, 'foo');
 * assertIs(alias.name, 'foo');
 * ```
 *
 * @function
 * @param {String} name The new name of the function.
 * @param {Function} fn The function to assign a name to
 * @returns {Function} The function
 */
const withFunctionName = (name, fn) => {
  Object.defineProperty(fn, 'name', { value: name });
  return fn;
};

/**
 * Autocurry a function!
 *
 * https://en.wikipedia.org/wiki/Currying
 *
 * Any function that has a fixed number of parameters may be curried!
 * Curried parameters will be in reverse order. This is useful for
 * functional programming, because it allows us to use function parameters
 * in the suffix position when using no curring:
 *
 * ```js
 * const { strictEqual: assertIs, throws: assertThrows } = require('assert');
 * const { assertSequenceEquals, iter, curry } = require('ferrum');
 *
 * // Declare a curried function
 * const fmt = curry('fmt', (a, b) => `${a} | ${b}`);
 * assertIs(fmt.name, 'fmt [CURRY]');
 *
 * // Now you derive a secondary function like this:
 * const fmtZ = fmt('Z');
 *
 * // And finally use it. Notice how the parameters are
 * // applied in reverse order?
 * assertIs(fmtZ('Y'), 'Y | Z');
 *
 * // Reverse order is not applied when we specify multiple arguments.
 * // In this example, arguments are applied in the order you would
 * // normally expect.
 * assertIs(fmt(1, 2), '1 | 2');
 *
 * // This property is useful for functions like the iterator map function…
 * const map = curry('map', function* (seq, fn) {
 *   for (const v of iter(seq)) {
 *     yield fn(v);
 *   }
 * });
 * assertIs(map.name, 'map [CURRY]');
 *
 * // We can curry map with the function, as you would expect
 * const addOneToEach = map(x => x+1);
 * assertSequenceEquals(
 *   addOneToEach([1,2,3]),
 *   [2, 3, 4]);
 *
 * // We can use the map function either at once, with the function in the prefix
 * // position. This is a lot more convenient than having the function as the first
 * // argument, especially for functions that span multiple lines.
 * assertSequenceEquals(
 *   map([1, 2, 3], (x) => x+1),
 *   [2, 3, 4]);
 *
 * // When a function has multiple parameters this rule is pretty much the same,
 * // arguments applied together in normal order, arguments applied in separate
 * // steps are in reverse order. This keeps the function as the last parameter
 * // in most cases.
 * const foldl = curry('foldl', (seq, init, fn) => {
 *   let r = init;
 *   for (const v of iter(seq)) {
 *     r = fn(r, v);
 *   }
 *   return r;
 * });
 * assertIs(foldl.name, 'foldl [CURRY]');
 *
 * // Applies init, fn
 * const sum = foldl(0, (a, b) => a+b);
 *
 * // Finally applies the sequence
 * assertIs(sum([1, 2, 3]), 6);
 *
 * // Curried functions will throw when invoked with the wrong number
 * // of arguments
 * assertThrows(() => sum(1, 2, 3));
 * ```
 *
 * @function
 * @param {String} name The name to given to the function
 * @param {Function} fn The function to curry
 * @returns {Function} The curryable function!
 */
const curry = (name, fn) => curry.impl(name, fn, fn.length, []);
curry.impl = (name, fn, arity, got) => withFunctionName(`${name} [CURRY]`, (...args) => {
  args.push(...got);
  if (args.length === arity) {
    return fn(...args);
  } else if (args.length &lt; arity) {
    return curry.impl(name, fn, arity, args);
  } else {
    throw new Error(`Too many arguments passed to ${name}; `
                    + `got ${args.length}; expected ${arity}`);
  }
});

/**
 * Apply a list of arguments to a function.
 *
 * This is very similar to [Function.prototype.apply()](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function/Apply),
 * or the [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax).
 *
 * What makes this function special is that it is curried, so it can actually
 * be used to transform a function taking multiple arguments into on taking a
 * single array.
 *
 * ```js
 * const { strictEqual: assertIs } = require('assert');
 * const { plus, apply, zip2, assertSequenceEquals, map } = require('ferrum');
 *
 * // Usage like the spread operator (you should probably just use
 * // the spread operator...)
 * const args = [5, 6];
 * assertIs(plus(...args),     11);
 * assertIs(apply(args, plus), 11);
 *
 * // Here is an example of how to use apply to transform a function into
 * // one that takes it's arguments as a list…e.g. to cleverly implement
 * // a function that can sum to vectors
 * const sumVec = (a, b) => map(zip2(a, b), apply(plus));
 * assertSequenceEquals(
 *   sumVec([2, 4, 6], [3, 6, 9]),
 *   [5, 10, 15]);
 *
 * // This could also be written with the usual spread operator
 * const sumVec2 = (a, b) => map(zip2(a, b), (pair) => plus(...pair));
 * assertSequenceEquals(
 *   sumVec2([2, 4, 6], [3, 6, 9]),
 *   [5, 10, 15]);
 * ```
 *
 * @function
 * @param {Array} args
 * @param {Function} fn The function to apply to
 * @returns {*} Whatever the function returns
 * @see [apply1()](module-functional.html#~apply1)
 * @see [call()](module-functional.html#~call)
 */
const apply = curry('apply', (args, fn) => fn(...args));

/**
 * This is a simple wrapper that allows you to mutate a value and
 * return hat value..
 *
 * ```js
 * const { mutate, del, assertEquals, compose, pipe, isdef } = require('ferrum');
 *
 * // Del is a function that – by design – mutates its value instead
 * // of transforming it without returning the original value.
 * // If you still need to use it like an expression (i.e. returning a
 * // value for some reason) you can use mutate.
 * assertEquals(
 *   mutate({ foo: 42, bar: 11 }, del('foo')),
 *   { bar: 11 });
 *
 * // The example above would probably have better been implemented using
 * // a variable instead of mutate, but using mutate can be beneficial
 * // to avoid breaking up pipe() based functions – especially if they are less
 * // contrived than this example
 * const mutObject = (o) => pipe(
 *   o,
 *   mutate((v) => {
 *     v.bar = isdef(v.foo) ? v.foo*2 : 42;
 *   }),
 *   mutate(del('foo')));
 * assertEquals(mutObject({}),          { bar: 42 });
 * assertEquals(mutObject({ foo: 11 }), { bar: 22 })
 * ```
 *
 * @function
 * @template T
 * @param {T} v The value to mutate
 * @param {Function} fn The mutator function
 * @returns {T} Just returns the parameter v
 */
/* eslint-disable-next-line */ // (using the comma operator here)
const mutate = curry('mutate', (v, fn) => (fn(v), v));

/**
 * Calls a function with a single parameter.
 *
 * ```js
 * const assert = require('assert');
 * const { plus, apply1, let_in, exec, apply, pipe, mul } = require('ferrum');
 *
 * assert.strictEqual(apply1(3, plus(2)), 5);
 *
 * // As you may imagine, this function is a bit useless,
 * // because javascript has syntax sugar for function application
 * // which is called…function application.
 * assert.strictEqual(plus(2)(3), 5);
 * assert.strictEqual(plus(3, 2), 5);
 *
 * // In pretty much any situation you could use apply1,
 * // you could also just apply the function directly.
 * // However, in some situations, apply1 actually looks nicer.
 * // E.g. you can use apply1 like a let … in statement.
 * // Which is why apply1 is aliased as let_in
 * assert.strictEqual(
 *  let_in(14, (a) =>
 *    let_in(32, (b) =>
 *      (a*a) + (b*b) + (2*a*b))),
 *  2116) // (14 + 32)**2 = 2166;
 *
 * // Which looks much nicer than this, even with nicer indentation
 * assert.strictEqual(
 *  ((a) =>
 *    ((b) =>
 *      (a*a) + (b*b) + (2*a*b)
 *    )(32)
 *  )(14),
 *  2116) // (14 + 32)**2 = 2166;
 *
 * // Of course you could always just use variables normally;
 * // e.g. use exec() to open a scope so the variables do not
 * // leak outside where they are needed.
 * assert.strictEqual(
 *   exec(() => {
 *     const a = 14;
 *     const b = 32;
 *     return (a*a) + (b*b) + (2*a*b);
 *   }),
 *   2116);
 *
 * // You could even use apply as a more concise let…in statement;
 * // which version you like most is of course up to you, but I quite
 * // like the let_in variant because it is written in a functional style,
 * // does not leak variables, very concise and still easy to read. But
 * // that is a matter of taste.
 * assert.strictEqual(
 *  apply([14, 32], (a, b) =>
 *    (a*a) + (b*b) + (2*a*b)),
 *  2116); // (14 + 32)**2 = 2166;
 *
 * // Finally, another place where this can come in handy
 * // is inside a pipe to apply some custom function to the
 * // value.
 * assert.strictEqual(
 *   pipe(
 *     2,
 *     mul(3), // 6
 *     apply1((x) => x**x), // Raise X to itself
 *     plus(-1)),
 *   46655);
 *
 * // Of course it perfectly works to just supply the function
 * // itself directly, it just looks a bit odd and operator precedence
 * // looks a bit odd
 * assert.strictEqual(
 *   pipe(
 *     2,
 *     mul(3), // 6
 *     (x) => x**x, // Raise X to itself
 *     plus(-1)),
 *   46655);
 *
 * // This is especially relevant for multi line functions,
 * // e.g. you could supply debug output like this!
 * assert.strictEqual(
 *   pipe(
 *     2,
 *     mul(3), // 6
 *     apply1((x) => x**x), // Raise X to itself
 *     plus(-1)),
 *   46655);
 * ```
 *
 * # Version history
 *
 * - 1.9.0 Initial implementation
 *
 * @function
 * @param {*} arg
 * @param {Function} fn
 * @returns {Any} Whatever the function returns
 * @see [apply()](module-functional.html#~apply)
 */
const apply1 = curry('apply1', (arg, fn) => fn(arg));

/**
 * Temporarily define a variable in the scope of an expression.
 *
 * This really is just an alias for [apply1()](module-functional.html#~apply1)
 * which in turn is just syntax sugar function application. Check out
 * the apply1 documentation.
 *
 * ```js
 * const assert = require('assert');
 * const { let_in } = require('ferrum');
 *
 * // Using let_in allows you to define a variable that
 * // does not leak outside an expression.
 * const y = let_in(6, (x) => x**x + x)
 * assert.strictEqual(y, 46662);
 *
 * // Without let_in this could be written like this; which
 * // is suboptimal if x is not being used again…
 * const x = 6;
 * const y2 = x**x + x;
 * assert.strictEqual(y2, 46662);
 *
 * // You could also use it as syntax sugar to avoid a function
 * // body; e.g. here preprocessing is used to turn x into a number
 * const fx = (xString) =>
 *   let_in(Number(xString), (x) =>
 *     x**x + x);
 * assert.strictEqual(fx("6"), 46662);
 *
 * // Which desugars into a function with a const variable
 * // and a return statement; which is a bit more verbose,
 * // but will look much more familliar to javascript developers
 * const fx2 = (xString) => {
 *   const x = Number(xString);
 *   return x**x + x;
 * };
 * assert.strictEqual(fx2("6"), 46662);
 * ```
 *
 * # Version history
 *
 * - 1.9.0 Initial implementation
 *
 * @function
 * @param {*} arg
 * @param {Function} fn
 * @returns {Any} Whatever the function returns
 * @see [apply1()](module-functional.html#~apply1)
 */
// eslint-disable-next-line camelcase
const let_in = curry('let_in', (arg, fn) => fn(arg));

/**
 * Calls a function.
 *
 * ```js
 * const assert = require('assert');
 * const {
 *   call, apply, plus, mul, apply1, each, get, map,
 *   assertSequenceEquals, compose, pipe,
 * } = require('ferrum');
 *
 * // Arguments are given as a sequence
 * assert.strictEqual(call(plus, [2,3]), 5)
 *
 * // This is the same as apply(), but with reversed parameters
 * // Partial application on apply turns a function into one that
 * // takes a sequence of arguments, while partial application on
 * // call stores a list of arguments for reuse.
 * assert.strictEqual(apply([2,3], plus), 5);
 *
 * // call() can be partially applied; this is basically storing
 * // a list of arguments, that can be applied to different functions.
 * const a2_5 = call([2, 5]);
 * assertSequenceEquals(
 *   map(
 *     [plus, mul, (x, y) => x**y],
 *     a2_5),
 *   [7, 10, 32]); // 2+5, 2*5, 2^5
 *
 * // This pattern could be used to invoke event handlers
 * const handlers = [];
 * const fire = (param) => each(handlers, call([param]));
 *
 * // In classic javascript this would look something like this
 * const fire2 = (param) => {
 *   handlers.map((fn) => fn(param));
 * };
 *
 * // Or without Array::map
 * const fire3 = (param) => {
 *   for (const fn of handlers) {
 *     fn(param);
 *   }
 * };
 *
 * // You could also use this as part of a pipeline to invoke
 * // a function.
 * const ops = {
 *   plus,
 *   mul,
 *   pow: (a, b) => a**b,
 * };
 * const evaluate = (op, a, b) => pipe(
 *   get(ops, op),
 *   call([Number(a), Number(b)]));
 * assert.strictEqual(evaluate("plus", 2, 3), 5);
 * assert.strictEqual(evaluate("mul", 2, 3), 6);
 * assert.strictEqual(evaluate("pow", 2, 3), 8);
 * ```
 *
 * # Version history
 *
 * - 1.9.0 Initial implementation
 *
 * @function
 * @param {Function} fn
 * @param {Sequence} args
 * @returns {*} Whatever the function returns
 * @see [apply()](module-functional.html#~apply)
 */
const call = curry('call', (fn, args) => apply(args, fn));

module.exports = {
  exec,
  identity,
  pipe,
  compose,
  withFunctionName,
  curry,
  apply,
  apply1,
  call,
  mutate,
  let_in,
};
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Fri Apr 16 2021 17:04:33 GMT+0200 (Central European Summer Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
