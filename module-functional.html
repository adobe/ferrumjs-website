<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>functional - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-hashing-DefaultHasher.html">DefaultHasher</a><ul class='methods'><li data-type='method'><a href="module-hashing-DefaultHasher.html#.fromSeed">fromSeed</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#.new">new</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#.withOpts">withOpts</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#buildHasher">buildHasher</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#digest">digest</a></li><li data-type='method'><a href="module-hashing-DefaultHasher.html#update">update</a></li></ul></li><li><a href="module-hashing-HashMap.html">HashMap</a><ul class='methods'><li data-type='method'><a href="module-hashing-HashMap.html#.fromSeq">fromSeq</a></li><li data-type='method'><a href="module-hashing-HashMap.html#.fromSeqWithOpts">fromSeqWithOpts</a></li><li data-type='method'><a href="module-hashing-HashMap.html#.new">new</a></li><li data-type='method'><a href="module-hashing-HashMap.html#clear">clear</a></li><li data-type='method'><a href="module-hashing-HashMap.html#delete">delete</a></li><li data-type='method'><a href="module-hashing-HashMap.html#entries">entries</a></li><li data-type='method'><a href="module-hashing-HashMap.html#forEach">forEach</a></li><li data-type='method'><a href="module-hashing-HashMap.html#get">get</a></li><li data-type='method'><a href="module-hashing-HashMap.html#getPair">getPair</a></li><li data-type='method'><a href="module-hashing-HashMap.html#has">has</a></li><li data-type='method'><a href="module-hashing-HashMap.html#keys">keys</a></li><li data-type='method'><a href="module-hashing-HashMap.html#set">set</a></li><li data-type='method'><a href="module-hashing-HashMap.html#size">size</a></li><li data-type='method'><a href="module-hashing-HashMap.html#values">values</a></li></ul></li><li><a href="module-hashing-HashSet.html">HashSet</a><ul class='methods'><li data-type='method'><a href="module-hashing-HashSet.html#.fromSeq">fromSeq</a></li><li data-type='method'><a href="module-hashing-HashSet.html#.fromSeqWithOpts">fromSeqWithOpts</a></li><li data-type='method'><a href="module-hashing-HashSet.html#.new">new</a></li><li data-type='method'><a href="module-hashing-HashSet.html#add">add</a></li><li data-type='method'><a href="module-hashing-HashSet.html#clear">clear</a></li><li data-type='method'><a href="module-hashing-HashSet.html#delete">delete</a></li><li data-type='method'><a href="module-hashing-HashSet.html#entries">entries</a></li><li data-type='method'><a href="module-hashing-HashSet.html#forEach">forEach</a></li><li data-type='method'><a href="module-hashing-HashSet.html#get">get</a></li><li data-type='method'><a href="module-hashing-HashSet.html#has">has</a></li><li data-type='method'><a href="module-hashing-HashSet.html#size">size</a></li><li data-type='method'><a href="module-hashing-HashSet.html#values">values</a></li></ul></li><li><a href="module-hashing-UnorderedHasher.html">UnorderedHasher</a><ul class='methods'><li data-type='method'><a href="module-hashing-UnorderedHasher.html#.fromBuildHasher">fromBuildHasher</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#.new">new</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#.withOpts">withOpts</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#buildHasher">buildHasher</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#digest">digest</a></li><li data-type='method'><a href="module-hashing-UnorderedHasher.html#update">update</a></li></ul></li><li><a href="module-trait-HybridWeakMap.html">HybridWeakMap</a></li><li><a href="module-trait-Trait.html">Trait</a><ul class='methods'><li data-type='method'><a href="module-trait-Trait.html#impl">impl</a></li><li data-type='method'><a href="module-trait-Trait.html#implDerived">implDerived</a></li><li data-type='method'><a href="module-trait-Trait.html#implStatic">implStatic</a></li><li data-type='method'><a href="module-trait-Trait.html#implWild">implWild</a></li><li data-type='method'><a href="module-trait-Trait.html#implWildStatic">implWildStatic</a></li><li data-type='method'><a href="module-trait-Trait.html#invoke">invoke</a></li><li data-type='method'><a href="module-trait-Trait.html#lookupType">lookupType</a></li><li data-type='method'><a href="module-trait-Trait.html#lookupValue">lookupValue</a></li></ul></li><li><a href="module-trait-TraitNotImplemented.html">TraitNotImplemented</a></li></ul><h3>Modules</h3><ul><li><a href="module-functional.html">functional</a><ul class='methods'><li data-type='method'><a href="module-functional.html#~apply">apply</a></li><li data-type='method'><a href="module-functional.html#~apply1">apply1</a></li><li data-type='method'><a href="module-functional.html#~call">call</a></li><li data-type='method'><a href="module-functional.html#~compose">compose</a></li><li data-type='method'><a href="module-functional.html#~curry">curry</a></li><li data-type='method'><a href="module-functional.html#~exec">exec</a></li><li data-type='method'><a href="module-functional.html#~identity">identity</a></li><li data-type='method'><a href="module-functional.html#~let_in">let_in</a></li><li data-type='method'><a href="module-functional.html#~pipe">pipe</a></li><li data-type='method'><a href="module-functional.html#~withFunctionName">withFunctionName</a></li></ul></li><li><a href="module-hashing.html">hashing</a><ul class='methods'><li data-type='method'><a href="module-hashing.html#~bytes2hex">bytes2hex</a></li><li data-type='method'><a href="module-hashing.html#~defaultBuildHasher">defaultBuildHasher</a></li><li data-type='method'><a href="module-hashing.html#~hash">hash</a></li><li data-type='method'><a href="module-hashing.html#~hashDirectly">hashDirectly</a></li><li data-type='method'><a href="module-hashing.html#~hashmap">hashmap</a></li><li data-type='method'><a href="module-hashing.html#~hashSeq">hashSeq</a></li><li data-type='method'><a href="module-hashing.html#~hashSeqWith">hashSeqWith</a></li><li data-type='method'><a href="module-hashing.html#~hashset">hashset</a></li><li data-type='method'><a href="module-hashing.html#~hashUnordered">hashUnordered</a></li><li data-type='method'><a href="module-hashing.html#~hashUnorderedWith">hashUnorderedWith</a></li><li data-type='method'><a href="module-hashing.html#~hashWith">hashWith</a></li><li data-type='method'><a href="module-hashing.html#~hex2bytes">hex2bytes</a></li><li data-type='method'><a href="module-hashing.html#~randomBuildHasher">randomBuildHasher</a></li><li data-type='method'><a href="module-hashing.html#~seededBuildHasher">seededBuildHasher</a></li><li data-type='method'><a href="module-hashing.html#~unorderedBuildHasher">unorderedBuildHasher</a></li></ul></li><li><a href="module-op.html">op</a><ul class='methods'><li data-type='method'><a href="module-op.html#~aint">aint</a></li><li data-type='method'><a href="module-op.html#~and">and</a></li><li data-type='method'><a href="module-op.html#~is">is</a></li><li data-type='method'><a href="module-op.html#~mul">mul</a></li><li data-type='method'><a href="module-op.html#~nand">nand</a></li><li data-type='method'><a href="module-op.html#~nor">nor</a></li><li data-type='method'><a href="module-op.html#~not">not</a></li><li data-type='method'><a href="module-op.html#~or">or</a></li><li data-type='method'><a href="module-op.html#~plus">plus</a></li><li data-type='method'><a href="module-op.html#~xnor">xnor</a></li><li data-type='method'><a href="module-op.html#~xor">xor</a></li></ul></li><li><a href="module-sequence.html">sequence</a><ul class='methods'><li data-type='method'><a href="module-sequence.html#~all">all</a></li><li data-type='method'><a href="module-sequence.html#~any">any</a></li><li data-type='method'><a href="module-sequence.html#~append">append</a></li><li data-type='method'><a href="module-sequence.html#~assertSequenceEquals">assertSequenceEquals</a></li><li data-type='method'><a href="module-sequence.html#~cartesian">cartesian</a></li><li data-type='method'><a href="module-sequence.html#~cartesian2">cartesian2</a></li><li data-type='method'><a href="module-sequence.html#~chunkify">chunkify</a></li><li data-type='method'><a href="module-sequence.html#~chunkifyShort">chunkifyShort</a></li><li data-type='method'><a href="module-sequence.html#~chunkifyWithFallback">chunkifyWithFallback</a></li><li data-type='method'><a href="module-sequence.html#~concat">concat</a></li><li data-type='method'><a href="module-sequence.html#~contains">contains</a></li><li data-type='method'><a href="module-sequence.html#~count">count</a></li><li data-type='method'><a href="module-sequence.html#~dict">dict</a></li><li data-type='method'><a href="module-sequence.html#~each">each</a></li><li data-type='method'><a href="module-sequence.html#~enumerate">enumerate</a></li><li data-type='method'><a href="module-sequence.html#~extend">extend</a></li><li data-type='method'><a href="module-sequence.html#~extend1">extend1</a></li><li data-type='method'><a href="module-sequence.html#~filter">filter</a></li><li data-type='method'><a href="module-sequence.html#~find">find</a></li><li data-type='method'><a href="module-sequence.html#~first">first</a></li><li data-type='method'><a href="module-sequence.html#~flat">flat</a></li><li data-type='method'><a href="module-sequence.html#~flattenTree">flattenTree</a></li><li data-type='method'><a href="module-sequence.html#~foldl">foldl</a></li><li data-type='method'><a href="module-sequence.html#~foldr">foldr</a></li><li data-type='method'><a href="module-sequence.html#~group">group</a></li><li data-type='method'><a href="module-sequence.html#~intersperse">intersperse</a></li><li data-type='method'><a href="module-sequence.html#~into">into</a></li><li data-type='method'><a href="module-sequence.html#~iter">iter</a></li><li data-type='method'><a href="module-sequence.html#~join">join</a></li><li data-type='method'><a href="module-sequence.html#~last">last</a></li><li data-type='method'><a href="module-sequence.html#~list">list</a></li><li data-type='method'><a href="module-sequence.html#~lookahead">lookahead</a></li><li data-type='method'><a href="module-sequence.html#~map">map</a></li><li data-type='method'><a href="module-sequence.html#~mapSort">mapSort</a></li><li data-type='method'><a href="module-sequence.html#~mod">mod</a></li><li data-type='method'><a href="module-sequence.html#~next">next</a></li><li data-type='method'><a href="module-sequence.html#~nth">nth</a></li><li data-type='method'><a href="module-sequence.html#~obj">obj</a></li><li data-type='method'><a href="module-sequence.html#~prepend">prepend</a></li><li data-type='method'><a href="module-sequence.html#~product">product</a></li><li data-type='method'><a href="module-sequence.html#~range">range</a></li><li data-type='method'><a href="module-sequence.html#~range0">range0</a></li><li data-type='method'><a href="module-sequence.html#~reject">reject</a></li><li data-type='method'><a href="module-sequence.html#~repeat">repeat</a></li><li data-type='method'><a href="module-sequence.html#~repeatFn">repeatFn</a></li><li data-type='method'><a href="module-sequence.html#~reverse">reverse</a></li><li data-type='method'><a href="module-sequence.html#~second">second</a></li><li data-type='method'><a href="module-sequence.html#~seqEq">seqEq</a></li><li data-type='method'><a href="module-sequence.html#~skip">skip</a></li><li data-type='method'><a href="module-sequence.html#~skipWhile">skipWhile</a></li><li data-type='method'><a href="module-sequence.html#~slidingWindow">slidingWindow</a></li><li data-type='method'><a href="module-sequence.html#~sum">sum</a></li><li data-type='method'><a href="module-sequence.html#~take">take</a></li><li data-type='method'><a href="module-sequence.html#~takeDef">takeDef</a></li><li data-type='method'><a href="module-sequence.html#~takeUntil">takeUntil</a></li><li data-type='method'><a href="module-sequence.html#~takeUntilVal">takeUntilVal</a></li><li data-type='method'><a href="module-sequence.html#~takeWithFallback">takeWithFallback</a></li><li data-type='method'><a href="module-sequence.html#~tryFind">tryFind</a></li><li data-type='method'><a href="module-sequence.html#~tryFirst">tryFirst</a></li><li data-type='method'><a href="module-sequence.html#~tryLast">tryLast</a></li><li data-type='method'><a href="module-sequence.html#~tryNext">tryNext</a></li><li data-type='method'><a href="module-sequence.html#~tryNth">tryNth</a></li><li data-type='method'><a href="module-sequence.html#~trySecond">trySecond</a></li><li data-type='method'><a href="module-sequence.html#~trySkip">trySkip</a></li><li data-type='method'><a href="module-sequence.html#~trySlidingWindow">trySlidingWindow</a></li><li data-type='method'><a href="module-sequence.html#~union">union</a></li><li data-type='method'><a href="module-sequence.html#~union2">union2</a></li><li data-type='method'><a href="module-sequence.html#~uniq">uniq</a></li><li data-type='method'><a href="module-sequence.html#~zip">zip</a></li><li data-type='method'><a href="module-sequence.html#~zip2">zip2</a></li><li data-type='method'><a href="module-sequence.html#~zipLeast">zipLeast</a></li><li data-type='method'><a href="module-sequence.html#~zipLeast2">zipLeast2</a></li><li data-type='method'><a href="module-sequence.html#~zipLongest">zipLongest</a></li><li data-type='method'><a href="module-sequence.html#~zipLongest2">zipLongest2</a></li></ul></li><li><a href="module-stdtraits.html">stdtraits</a><ul class='methods'><li data-type='method'><a href="module-stdtraits.html#~assertEquals">assertEquals</a></li><li data-type='method'><a href="module-stdtraits.html#~assertUneq">assertUneq</a></li><li data-type='method'><a href="module-stdtraits.html#~assign">assign</a></li><li data-type='method'><a href="module-stdtraits.html#~deepclone">deepclone</a></li><li data-type='method'><a href="module-stdtraits.html#~del">del</a></li><li data-type='method'><a href="module-stdtraits.html#~empty">empty</a></li><li data-type='method'><a href="module-stdtraits.html#~eq">eq</a></li><li data-type='method'><a href="module-stdtraits.html#~get">get</a></li><li data-type='method'><a href="module-stdtraits.html#~has">has</a></li><li data-type='method'><a href="module-stdtraits.html#~isImmutable">isImmutable</a></li><li data-type='method'><a href="module-stdtraits.html#~keys">keys</a></li><li data-type='method'><a href="module-stdtraits.html#~pairs">pairs</a></li><li data-type='method'><a href="module-stdtraits.html#~replace">replace</a></li><li data-type='method'><a href="module-stdtraits.html#~setdefault">setdefault</a></li><li data-type='method'><a href="module-stdtraits.html#~shallowclone">shallowclone</a></li><li data-type='method'><a href="module-stdtraits.html#~size">size</a></li><li data-type='method'><a href="module-stdtraits.html#~typeIsImmutable">typeIsImmutable</a></li><li data-type='method'><a href="module-stdtraits.html#~uneq">uneq</a></li><li data-type='method'><a href="module-stdtraits.html#~values">values</a></li></ul></li><li><a href="module-trait.html">trait</a><ul class='methods'><li data-type='method'><a href="module-trait.html#~supports">supports</a></li><li data-type='method'><a href="module-trait.html#~valueSupports">valueSupports</a></li></ul></li><li><a href="module-typesafe.html">typesafe</a><ul class='methods'><li data-type='method'><a href="module-typesafe.html#~builder">builder</a></li><li data-type='method'><a href="module-typesafe.html#~create">create</a></li><li data-type='method'><a href="module-typesafe.html#~createFrom">createFrom</a></li><li data-type='method'><a href="module-typesafe.html#~ifdef">ifdef</a></li><li data-type='method'><a href="module-typesafe.html#~isdef">isdef</a></li><li data-type='method'><a href="module-typesafe.html#~isPrimitive">isPrimitive</a></li><li data-type='method'><a href="module-typesafe.html#~type">type</a></li><li data-type='method'><a href="module-typesafe.html#~typename">typename</a></li></ul></li></ul><h3>Interfaces</h3><ul><li><a href="module-hashing-Hashable.html">Hashable</a></li><li><a href="module-hashing-Hasher.html">Hasher</a></li><li><a href="module-sequence-Into.html">Into</a></li><li><a href="module-sequence-Sequence.html">Sequence</a></li><li><a href="module-stdtraits-Assign.html">Assign</a></li><li><a href="module-stdtraits-Deepclone.html">Deepclone</a></li><li><a href="module-stdtraits-Delete.html">Delete</a></li><li><a href="module-stdtraits-Equals.html">Equals</a></li><li><a href="module-stdtraits-Get.html">Get</a></li><li><a href="module-stdtraits-Has.html">Has</a></li><li><a href="module-stdtraits-Immutable.html">Immutable</a></li><li><a href="module-stdtraits-Pairs.html">Pairs</a></li><li><a href="module-stdtraits-Replace.html">Replace</a></li><li><a href="module-stdtraits-Setdefault.html">Setdefault</a></li><li><a href="module-stdtraits-Shallowclone.html">Shallowclone</a></li><li><a href="module-stdtraits-Size.html">Size</a></li></ul><h3>Global</h3><ul><li><a href="global.html#flatten">flatten</a></li><li><a href="global.html#multiline">multiline</a></li><li><a href="global.html#takeShort">takeShort</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">functional</h1>
    

    




<section>

<header>
    
        
            
        
    
</header>

<article>
    
        <div class="container-overview">
        
            
                <div class="description usertext"><p>Gen­eric lib­rary for func­tional pro­gram­ming &amp; work­ing with func­tions.</p></div>
            

            
                




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functional.js.html">functional.js</a>, <a href="functional.js.html#line13">line 13</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>
































            
        
        </div>
    

    

    

    
    
    

     

    

    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id="~apply"><span class="type-signature">(inner) </span>apply<span class="signature">(args, fn)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functional.js.html">functional.js</a>, <a href="functional.js.html#line291">line 291</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li><p><a href="module-functional.html#~apply1">apply1()</a></p></li>
        
            <li><p><a href="module-functional.html#~call">call()</a></p></li>
        </ul>
    </dd>
    

    
</dl>





<div class="description usertext">
    <p>Ap­ply a list of ar­gu­ments to a func­tion.</p>
<p>This is very sim­ilar to <a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function/Apply">Func­tion.pro­to­type.ap­ply()</a>,
or the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">spread syn­tax</a>.</p>
<p>What makes this func­tion spe­cial is that it is cur­ried, so it can ac­tu­ally
be used to trans­form a func­tion tak­ing mul­tiple ar­gu­ments into on tak­ing a
single ar­ray.</p>
<pre class="prettyprint source lang-js"><code>const { stric­tEqual: as­sertIs } = re­quire('assert');
const { plus, ap­ply, zip2, as­sertSequenceEquals, map } = re­quire('fer­rum');

// Us­age like the spread op­er­ator (you should prob­ably just use
// the spread op­er­ator...)
const args = [5, 6];
as­sertIs(plus(...args),     11);
as­sertIs(ap­ply(args, plus), 11);

// Here is an ex­ample of how to use ap­ply to trans­form a func­tion into
// one that takes it's ar­gu­ments as a list…e.g. to clev­erly im­ple­ment
// a func­tion that can sum to vec­tors
const sum­Vec = (a, b) =&gt; map(zip2(a, b), ap­ply(plus));
as­sertSequenceEquals(
  sum­Vec([2, 4, 6], [3, 6, 9]),
  [5, 10, 15]);

// This could also be writ­ten with the usual spread op­er­ator
const sum­Vec2 = (a, b) =&gt; map(zip2(a, b), (pair) =&gt; plus(...pair));
as­sertSequenceEquals(
  sum­Vec2([2, 4, 6], [3, 6, 9]),
  [5, 10, 15]);
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>args</code></td>
            

            <td class="type">
            
                
<span class="param-type">Array</span>


            
            </td>

            

            

            <td class="description last"></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The func­tion to ap­ply to</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Whatever the func­tion re­turns</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id="~apply1"><span class="type-signature">(inner) </span>apply1<span class="signature">(arg, fn)</span><span class="type-signature"> &rarr; {Any}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functional.js.html">functional.js</a>, <a href="functional.js.html#line430">line 430</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li><p><a href="module-functional.html#~apply">apply()</a></p></li>
        </ul>
    </dd>
    

    
</dl>





<div class="description usertext">
    <p>Calls a func­tion with a single para­meter.</p>
<pre class="prettyprint source lang-js"><code>const as­sert = re­quire('assert');
const { plus, ap­ply1, let_in, exec, ap­ply, pipe, mul } = re­quire('fer­rum');

as­sert.stric­tEqual(ap­ply1(3, plus(2)), 5);

// As you may ima­gine, this func­tion is a bit use­less,
// be­cause javas­cript has syn­tax sugar for func­tion ap­plic­a­tion
// which is called…func­tion ap­plic­a­tion.
as­sert.stric­tEqual(plus(2)(3), 5);
as­sert.stric­tEqual(plus(3, 2), 5);

// In pretty much any situ­ation you could use ap­ply1,
// you could also just ap­ply the func­tion dir­ectly.
// However, in some situ­ations, ap­ply1 ac­tu­ally looks nicer.
// E.g. you can use ap­ply1 like a let … in state­ment.
// Which is why ap­ply1 is aliased as let_in
as­sert.stric­tEqual(
 let_in(14, (a) =&gt;
   let_in(32, (b) =&gt;
     (a*a) + (b*b) + (2*a*b))),
 2116) // (14 + 32)**2 = 2166;

// Which looks much nicer than this, even with nicer in­dent­a­tion
as­sert.stric­tEqual(
 ((a) =&gt;
   ((b) =&gt;
     (a*a) + (b*b) + (2*a*b)
   )(32)
 )(14),
 2116) // (14 + 32)**2 = 2166;

// Of course you could al­ways just use vari­ables nor­mally;
// e.g. use exec() to open a scope so the vari­ables do not
// leak out­side where they are needed.
as­sert.stric­tEqual(
  exec(() =&gt; {
    const a = 14;
    const b = 32;
    re­turn (a*a) + (b*b) + (2*a*b);
  }),
  2116);

// You could even use ap­ply as a more con­cise let…in state­ment;
// which ver­sion you like most is of course up to you, but I quite
// like the let_in vari­ant be­cause it is writ­ten in a func­tional style,
// does not leak vari­ables, very con­cise and still easy to read. But
// that is a mat­ter of taste.
as­sert.stric­tEqual(
 ap­ply([14, 32], (a, b) =&gt;
   (a*a) + (b*b) + (2*a*b)),
 2116); // (14 + 32)**2 = 2166;

// Fi­nally, an­other place where this can come in handy
// is in­side a pipe to ap­ply some cus­tom func­tion to the
// value.
as­sert.stric­tEqual(
  pipe(
    2,
    mul(3), // 6
    ap­ply1((x) =&gt; x**x), // Raise X to it­self
    plus(-1)),
  46655);

// Of course it per­fectly works to just sup­ply the func­tion
// it­self dir­ectly, it just looks a bit odd and op­er­ator pre­ced­ence
// looks a bit odd
as­sert.stric­tEqual(
  pipe(
    2,
    mul(3), // 6
    (x) =&gt; x**x, // Raise X to it­self
    plus(-1)),
  46655);

// This is es­pe­cially rel­ev­ant for multi line func­tions,
// e.g. you could sup­ply de­bug out­put like this!
as­sert.stric­tEqual(
  pipe(
    2,
    mul(3), // 6
    ap­ply1((x) =&gt; x**x), // Raise X to it­self
    plus(-1)),
  46655);
</code></pre>
<h1>Ver­sion his­tory</h1>
<ul>
<li>1.9.0 Ini­tial im­ple­ment­a­tion</li>
</ul>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>arg</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Whatever the func­tion re­turns</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Any</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id="~call"><span class="type-signature">(inner) </span>call<span class="signature">(fn, args)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functional.js.html">functional.js</a>, <a href="functional.js.html#line553">line 553</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li><p><a href="module-functional.html#~apply">apply()</a></p></li>
        </ul>
    </dd>
    

    
</dl>





<div class="description usertext">
    <p>Calls a func­tion.</p>
<pre class="prettyprint source lang-js"><code>const as­sert = re­quire('assert');
const {
  call, ap­ply, plus, mul, ap­ply1, each, get, map,
  as­sertSequenceEquals, com­pose, pipe,
} = re­quire('fer­rum');

// Ar­gu­ments are given as a se­quence
as­sert.stric­tEqual(call(plus, [2,3]), 5)

// This is the same as ap­ply(), but with re­versed para­met­ers
// Par­tial ap­plic­a­tion on ap­ply turns a func­tion into one that
// takes a se­quence of ar­gu­ments, while par­tial ap­plic­a­tion on
// call stores a list of ar­gu­ments for re­use.
as­sert.stric­tEqual(ap­ply([2,3], plus), 5);

// call() can be par­tially ap­plied; this is ba­sic­ally stor­ing
// a list of ar­gu­ments, that can be ap­plied to dif­fer­ent func­tions.
const a2_5 = call([2, 5]);
as­sertSequenceEquals(
  map(
    [plus, mul, (x, y) =&gt; x**y],
    a2_5),
  [7, 10, 32]); // 2+5, 2*5, 2^5

// This pat­tern could be used to in­voke event hand­lers
const hand­lers = [];
const fire = (param) =&gt; each(hand­lers, call([param]));

// In clas­sic javas­cript this would look something like this
const fire2 = (param) =&gt; {
  hand­lers.map((fn) =&gt; fn(param));
};

// Or without Ar­ray::map
const fire3 = (param) =&gt; {
  for (const fn of hand­lers) {
    fn(param);
  }
};

// You could also use this as part of a pipeline to in­voke
// a func­tion.
const ops = {
  plus,
  mul,
  pow: (a, b) =&gt; a**b,
};
const eval­u­ate = (op, a, b) =&gt; pipe(
  get(ops, op),
  call([Num­ber(a), Num­ber(b)]));
as­sert.stric­tEqual(eval­u­ate("plus", 2, 3), 5);
as­sert.stric­tEqual(eval­u­ate("mul", 2, 3), 6);
as­sert.stric­tEqual(eval­u­ate("pow", 2, 3), 8);
</code></pre>
<h1>Ver­sion his­tory</h1>
<ul>
<li>1.9.0 Ini­tial im­ple­ment­a­tion</li>
</ul>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>args</code></td>
            

            <td class="type">
            
                
<span class="param-type">Sequence</span>


            
            </td>

            

            

            <td class="description last"></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Whatever the func­tion re­turns</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id="~compose"><span class="type-signature">(inner) </span>compose<span class="signature">(&hellip;fns)</span><span class="type-signature"> &rarr; {function}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functional.js.html">functional.js</a>, <a href="functional.js.html#line129">line 129</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Func­tion com­pos­i­tion.</p>
<p>This es­sen­tially be­haves like <code>pipe()</code> without tak­ing the ini­tial ar­gu­ment:
ex­ecuted left-to-right/​top-to-bot­tom.</p>
<pre class="prettyprint source lang-js"><code>const { stric­tEqual: as­sertIs } = re­quire('assert');
const { com­pose, plus, mul } = re­quire('fer­rum');

const fn = com­pose(plus(2), mul(3), x =&gt; `My Num­ber ${x}`);
as­sertIs(fn(4), 'My Num­ber 18');
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fns</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                    &lt;repeatable><br>
                
                </td>
            

            

            <td class="description last"><p>Mul­tiple func­tions</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>All the func­tions in the se­quence com­posed into one</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id="~curry"><span class="type-signature">(inner) </span>curry<span class="signature">(name, fn)</span><span class="type-signature"> &rarr; {function}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functional.js.html">functional.js</a>, <a href="functional.js.html#line236">line 236</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Auto­curry a func­tion!</p>
<p>ht­tps://​en.wiki­pe­dia.org/​wiki/​Cur­ry­ing</p>
<p>Any func­tion that has a fixed num­ber of para­met­ers may be cur­ried!
Cur­ried para­met­ers will be in re­verse or­der. This is use­ful for
func­tional pro­gram­ming, be­cause it al­lows us to use func­tion para­met­ers
in the suf­fix po­s­i­tion when us­ing no cur­ring:</p>
<pre class="prettyprint source lang-js"><code>const { stric­tEqual: as­sertIs, throws: as­sertThrows } = re­quire('assert');
const { as­sertSequenceEquals, iter, curry } = re­quire('fer­rum');

// De­clare a cur­ried func­tion
const fmt = curry('fmt', (a, b) =&gt; `${a} | ${b}`);
as­sertIs(fmt.name, 'fmt [CURRY]');

// Now you de­rive a sec­ond­ary func­tion like this:
const fmtZ = fmt('Z');

// And fi­nally use it. No­tice how the para­met­ers are
// ap­plied in re­verse or­der?
as­sertIs(fmtZ('Y'), 'Y | Z');

// Re­verse or­der is not ap­plied when we spe­cify mul­tiple ar­gu­ments.
// In this ex­ample, ar­gu­ments are ap­plied in the or­der you would
// nor­mally ex­pect.
as­sertIs(fmt(1, 2), '1 | 2');

// This prop­erty is use­ful for func­tions like the iter­ator map func­tion…
const map = curry('map', func­tion* (seq, fn) {
  for (const v of iter(seq)) {
    yield fn(v);
  }
});
as­sertIs(map.name, 'map [CURRY]');

// We can curry map with the func­tion, as you would ex­pect
const ad­dOn­e­ToE­ach = map(x =&gt; x+1);
as­sertSequenceEquals(
  ad­dOn­e­ToE­ach([1,2,3]),
  [2, 3, 4]);

// We can use the map func­tion either at once, with the func­tion in the pre­fix
// po­s­i­tion. This is a lot more con­veni­ent than hav­ing the func­tion as the first
// ar­gu­ment, es­pe­cially for func­tions that span mul­tiple lines.
as­sertSequenceEquals(
  map([1, 2, 3], (x) =&gt; x+1),
  [2, 3, 4]);

// When a func­tion has mul­tiple para­met­ers this rule is pretty much the same,
// ar­gu­ments ap­plied to­gether in nor­mal or­der, ar­gu­ments ap­plied in sep­ar­ate
// steps are in re­verse or­der. This keeps the func­tion as the last para­meter
// in most cases.
const foldl = curry('foldl', (seq, init, fn) =&gt; {
  let r = init;
  for (const v of iter(seq)) {
    r = fn(r, v);
  }
  re­turn r;
});
as­sertIs(foldl.name, 'foldl [CURRY]');

// Ap­plies init, fn
const sum = foldl(0, (a, b) =&gt; a+b);

// Fi­nally ap­plies the se­quence
as­sertIs(sum([1, 2, 3]), 6);

// Cur­ried func­tions will throw when in­voked with the wrong num­ber
// of ar­gu­ments
as­sertThrows(() =&gt; sum(1, 2, 3));
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>name</code></td>
            

            <td class="type">
            
                
<span class="param-type">String</span>


            
            </td>

            

            

            <td class="description last"><p>The name to given to the func­tion</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The func­tion to curry</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The curry­able func­tion!</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id="~exec"><span class="type-signature">(inner) </span>exec<span class="signature">(fn)</span><span class="type-signature"></span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functional.js.html">functional.js</a>, <a href="functional.js.html#line45">line 45</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Im­me­di­ately ex­ecute the given func­tion.</p>
<pre class="prettyprint source lang-js"><code>const { stric­tEqual: as­sertIs } = re­quire('assert');
const {exec} = re­quire('fer­rum');

// Nor­mal scopes can­not re­turn val­ues
let r;
{
  let x = 42, y = 5;
  r = x + y;
}
as­sertIs(r, 47);;

// Can be re­writ­ten as
const q = exec(() =&gt; {
  let x = 42, y = 5;
  re­turn  x + y;
});
as­sertIs(q, 47);;
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Whatever the given func­tion re­turns.</p>
</div>



    



        
            

    

    <h4 class="name" id="~identity"><span class="type-signature">(inner) </span>identity<span class="signature">(T)</span><span class="type-signature"> &rarr; {T}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functional.js.html">functional.js</a>, <a href="functional.js.html#line70">line 70</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Just a func­tion that re­turns it's ar­gu­ment!</p>
<pre class="prettyprint source lang-js"><code>const { stric­tEqual: as­sertIs } = re­quire('assert');
const { as­sertSequenceEquals, iden­tity, fil­ter } = re­quire('fer­rum');

as­sertIs(iden­tity(null), null);
as­sertIs(iden­tity(42),   42);

// Iden­tity is some­times use­ful in higher or­der func­tions like
// fil­ter(); this ex­ample for in­stance re­moves all val­ues from
// the list that are falsy
as­sertSequenceEquals(
  fil­ter([null, "asd", "", 42], iden­tity),
  ["asd", 42]);
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>T</code></td>
            

            <td class="type">
            
                
<span class="param-type">a</span>


            
            </td>

            

            

            <td class="description last"></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The para­meter</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">T</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id="~let_in"><span class="type-signature">(inner) </span>let_in<span class="signature">(arg, fn)</span><span class="type-signature"> &rarr; {Any}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functional.js.html">functional.js</a>, <a href="functional.js.html#line482">line 482</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li><p><a href="module-functional.html#~apply1">apply1()</a></p></li>
        </ul>
    </dd>
    

    
</dl>





<div class="description usertext">
    <p>Tem­por­ar­ily define a vari­able in the scope of an ex­pres­sion.</p>
<p>This really is just an alias for <a href="module-functional.html#~apply1">ap­ply1()</a>
which in turn is just syn­tax sugar func­tion ap­plic­a­tion. Check out
the ap­ply1 doc­u­ment­a­tion.</p>
<pre class="prettyprint source lang-js"><code>const as­sert = re­quire('assert');
const { let_in } = re­quire('fer­rum');

// Us­ing let_in al­lows you to define a vari­able that
// does not leak out­side an ex­pres­sion.
const y = let_in(6, (x) =&gt; x**x + x)
as­sert.stric­tEqual(y, 46662);

// Without let_in this could be writ­ten like this; which
// is sub­op­timal if x is not be­ing used again…
const x = 6;
const y2 = x**x + x;
as­sert.stric­tEqual(y2, 46662);

// You could also use it as syn­tax sugar to avoid a func­tion
// body; e.g. here pre­pro­cessing is used to turn x into a num­ber
const fx = (xString) =&gt;
  let_in(Num­ber(xString), (x) =&gt;
    x**x + x);
as­sert.stric­tEqual(fx("6"), 46662);

// Which de­sug­ars into a func­tion with a const vari­able
// and a re­turn state­ment; which is a bit more verb­ose,
// but will look much more fa­mil­liar to javas­cript de­velopers
const fx2 = (xString) =&gt; {
  const x = Num­ber(xString);
  re­turn x**x + x;
};
as­sert.stric­tEqual(fx2("6"), 46662);
</code></pre>
<h1>Ver­sion his­tory</h1>
<ul>
<li>1.9.0 Ini­tial im­ple­ment­a­tion</li>
</ul>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>arg</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Whatever the func­tion re­turns</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Any</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id="~pipe"><span class="type-signature">(inner) </span>pipe<span class="signature">(val, &hellip;fns)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functional.js.html">functional.js</a>, <a href="functional.js.html#line109">line 109</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Pipeline a value through mul­tiple func­tion calls.</p>
<pre class="prettyprint source lang-js"><code>const { as­sertSequenceEquals, pipe, fil­ter, uniq, map, plus, iden­tity } = re­quire('fer­rum');

// Some­times you want to use a lot of se­quence trans­form­a­tions;
// When you nest them this gets very hard to read
as­sertSequenceEquals(
  map(
    uniq(
      fil­ter(
        [1, 2, null, 3, 4, null, 5, 1, 3, 2, null, 1, 4],
        iden­tity
      )
    ),
    plus(2)),
  [3, 4, 5, 6, 7]);

// Pipe lets you re­format this com­plex, nes­ted ex­pres­sion so that
// the trans­former that is first ap­plied, is men­tioned first in the
// pipeline. Note that cur­ry­ing is used to make func­tions like fil­ter
// or map work nicely with pipe
as­sertSequenceEquals(
  pipe(
    [1, 2, null, 3, 4, null, 5, 1, 3, 2, null, 1, 4],
    fil­ter(iden­tity),
    uniq,
    map(plus(2))),
  [3, 4, 5, 6, 7]);
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>val</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last"><p>The value to pipe through the func­tions</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>fns</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                    &lt;repeatable><br>
                
                </td>
            

            

            <td class="description last"><p>Mul­tiple func­tions</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        


<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id="~withFunctionName"><span class="type-signature">(inner) </span>withFunctionName<span class="signature">(name, fn)</span><span class="type-signature"> &rarr; {function}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functional.js.html">functional.js</a>, <a href="functional.js.html#line151">line 151</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Manu­ally as­sign a name to a func­tion.</p>
<pre class="prettyprint source lang-js"><code>const { stric­tEqual: as­sertIs } = re­quire('assert');
const { with­Func­tion­Name } = re­quire('fer­rum');

const fn = () =&gt; {};
as­sertIs(fn.name, 'fn');

const alias = with­Func­tion­Name('foo', fn)
as­sertIs(fn.name, 'foo');
as­sertIs(alias.name, 'foo');
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>name</code></td>
            

            <td class="type">
            
                
<span class="param-type">String</span>


            
            </td>

            

            

            <td class="description last"><p>The new name of the func­tion.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The func­tion to as­sign a name to</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The func­tion</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    



        
    

    

    
</article>

</section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Fri Apr 16 2021 17:04:33 GMT+0200 (Central European Summer Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>